/**
 * This file was automatically generated by nexus-prisma@0.3.7
 * Do not make changes to this file directly
 */

import { core } from 'nexus'
import { GraphQLResolveInfo } from 'graphql'
import * as prisma from '../prisma-client'

declare global {
  interface NexusPrismaGen extends NexusPrismaTypes {}
}

export interface NexusPrismaTypes {
  objectTypes: {
    fields: {
      Query: QueryObject
      Vote: VoteObject
      Song: SongObject
      Bracket: BracketObject
      User: UserObject
      VoteConnection: VoteConnectionObject
      PageInfo: PageInfoObject
      VoteEdge: VoteEdgeObject
      AggregateVote: AggregateVoteObject
      UserConnection: UserConnectionObject
      UserEdge: UserEdgeObject
      AggregateUser: AggregateUserObject
      SongConnection: SongConnectionObject
      SongEdge: SongEdgeObject
      AggregateSong: AggregateSongObject
      BracketConnection: BracketConnectionObject
      BracketEdge: BracketEdgeObject
      AggregateBracket: AggregateBracketObject
      Mutation: MutationObject
      BatchPayload: BatchPayloadObject
      Subscription: SubscriptionObject
      VoteSubscriptionPayload: VoteSubscriptionPayloadObject
      VotePreviousValues: VotePreviousValuesObject
      UserSubscriptionPayload: UserSubscriptionPayloadObject
      UserPreviousValues: UserPreviousValuesObject
      SongSubscriptionPayload: SongSubscriptionPayloadObject
      SongPreviousValues: SongPreviousValuesObject
      BracketSubscriptionPayload: BracketSubscriptionPayloadObject
      BracketPreviousValues: BracketPreviousValuesObject
    }
    fieldsDetails: {
      Query: QueryFieldDetails
      Vote: VoteFieldDetails
      Song: SongFieldDetails
      Bracket: BracketFieldDetails
      User: UserFieldDetails
      VoteConnection: VoteConnectionFieldDetails
      PageInfo: PageInfoFieldDetails
      VoteEdge: VoteEdgeFieldDetails
      AggregateVote: AggregateVoteFieldDetails
      UserConnection: UserConnectionFieldDetails
      UserEdge: UserEdgeFieldDetails
      AggregateUser: AggregateUserFieldDetails
      SongConnection: SongConnectionFieldDetails
      SongEdge: SongEdgeFieldDetails
      AggregateSong: AggregateSongFieldDetails
      BracketConnection: BracketConnectionFieldDetails
      BracketEdge: BracketEdgeFieldDetails
      AggregateBracket: AggregateBracketFieldDetails
      Mutation: MutationFieldDetails
      BatchPayload: BatchPayloadFieldDetails
      Subscription: SubscriptionFieldDetails
      VoteSubscriptionPayload: VoteSubscriptionPayloadFieldDetails
      VotePreviousValues: VotePreviousValuesFieldDetails
      UserSubscriptionPayload: UserSubscriptionPayloadFieldDetails
      UserPreviousValues: UserPreviousValuesFieldDetails
      SongSubscriptionPayload: SongSubscriptionPayloadFieldDetails
      SongPreviousValues: SongPreviousValuesFieldDetails
      BracketSubscriptionPayload: BracketSubscriptionPayloadFieldDetails
      BracketPreviousValues: BracketPreviousValuesFieldDetails
    }
  }
  inputTypes: {
    fields: {
      VoteWhereUniqueInput: VoteWhereUniqueInputInputObject
      VoteWhereInput: VoteWhereInputInputObject
      SongWhereInput: SongWhereInputInputObject
      BracketWhereInput: BracketWhereInputInputObject
      UserWhereInput: UserWhereInputInputObject
      UserWhereUniqueInput: UserWhereUniqueInputInputObject
      SongWhereUniqueInput: SongWhereUniqueInputInputObject
      BracketWhereUniqueInput: BracketWhereUniqueInputInputObject
      VoteCreateInput: VoteCreateInputInputObject
      SongCreateOneWithoutVotesInput: SongCreateOneWithoutVotesInputInputObject
      SongCreateWithoutVotesInput: SongCreateWithoutVotesInputInputObject
      BracketCreateOneInput: BracketCreateOneInputInputObject
      BracketCreateInput: BracketCreateInputInputObject
      UserCreateOneWithoutBracketsInput: UserCreateOneWithoutBracketsInputInputObject
      UserCreateWithoutBracketsInput: UserCreateWithoutBracketsInputInputObject
      VoteCreateManyWithoutUserInput: VoteCreateManyWithoutUserInputInputObject
      VoteCreateWithoutUserInput: VoteCreateWithoutUserInputInputObject
      SongCreateManyInput: SongCreateManyInputInputObject
      SongCreateInput: SongCreateInputInputObject
      VoteCreateManyWithoutSongInput: VoteCreateManyWithoutSongInputInputObject
      VoteCreateWithoutSongInput: VoteCreateWithoutSongInputInputObject
      UserCreateOneWithoutVotesInput: UserCreateOneWithoutVotesInputInputObject
      UserCreateWithoutVotesInput: UserCreateWithoutVotesInputInputObject
      BracketCreateManyWithoutUserInput: BracketCreateManyWithoutUserInputInputObject
      BracketCreateWithoutUserInput: BracketCreateWithoutUserInputInputObject
      VoteUpdateInput: VoteUpdateInputInputObject
      SongUpdateOneWithoutVotesInput: SongUpdateOneWithoutVotesInputInputObject
      SongUpdateWithoutVotesDataInput: SongUpdateWithoutVotesDataInputInputObject
      SongUpsertWithoutVotesInput: SongUpsertWithoutVotesInputInputObject
      BracketUpdateOneInput: BracketUpdateOneInputInputObject
      BracketUpdateDataInput: BracketUpdateDataInputInputObject
      UserUpdateOneRequiredWithoutBracketsInput: UserUpdateOneRequiredWithoutBracketsInputInputObject
      UserUpdateWithoutBracketsDataInput: UserUpdateWithoutBracketsDataInputInputObject
      VoteUpdateManyWithoutUserInput: VoteUpdateManyWithoutUserInputInputObject
      VoteUpdateWithWhereUniqueWithoutUserInput: VoteUpdateWithWhereUniqueWithoutUserInputInputObject
      VoteUpdateWithoutUserDataInput: VoteUpdateWithoutUserDataInputInputObject
      VoteUpsertWithWhereUniqueWithoutUserInput: VoteUpsertWithWhereUniqueWithoutUserInputInputObject
      VoteScalarWhereInput: VoteScalarWhereInputInputObject
      VoteUpdateManyWithWhereNestedInput: VoteUpdateManyWithWhereNestedInputInputObject
      VoteUpdateManyDataInput: VoteUpdateManyDataInputInputObject
      UserUpsertWithoutBracketsInput: UserUpsertWithoutBracketsInputInputObject
      SongUpdateManyInput: SongUpdateManyInputInputObject
      SongUpdateWithWhereUniqueNestedInput: SongUpdateWithWhereUniqueNestedInputInputObject
      SongUpdateDataInput: SongUpdateDataInputInputObject
      VoteUpdateManyWithoutSongInput: VoteUpdateManyWithoutSongInputInputObject
      VoteUpdateWithWhereUniqueWithoutSongInput: VoteUpdateWithWhereUniqueWithoutSongInputInputObject
      VoteUpdateWithoutSongDataInput: VoteUpdateWithoutSongDataInputInputObject
      UserUpdateOneRequiredWithoutVotesInput: UserUpdateOneRequiredWithoutVotesInputInputObject
      UserUpdateWithoutVotesDataInput: UserUpdateWithoutVotesDataInputInputObject
      BracketUpdateManyWithoutUserInput: BracketUpdateManyWithoutUserInputInputObject
      BracketUpdateWithWhereUniqueWithoutUserInput: BracketUpdateWithWhereUniqueWithoutUserInputInputObject
      BracketUpdateWithoutUserDataInput: BracketUpdateWithoutUserDataInputInputObject
      BracketUpsertWithWhereUniqueWithoutUserInput: BracketUpsertWithWhereUniqueWithoutUserInputInputObject
      BracketScalarWhereInput: BracketScalarWhereInputInputObject
      BracketUpdateManyWithWhereNestedInput: BracketUpdateManyWithWhereNestedInputInputObject
      BracketUpdateManyDataInput: BracketUpdateManyDataInputInputObject
      UserUpsertWithoutVotesInput: UserUpsertWithoutVotesInputInputObject
      VoteUpsertWithWhereUniqueWithoutSongInput: VoteUpsertWithWhereUniqueWithoutSongInputInputObject
      SongUpsertWithWhereUniqueNestedInput: SongUpsertWithWhereUniqueNestedInputInputObject
      SongScalarWhereInput: SongScalarWhereInputInputObject
      SongUpdateManyWithWhereNestedInput: SongUpdateManyWithWhereNestedInputInputObject
      SongUpdateManyDataInput: SongUpdateManyDataInputInputObject
      BracketUpsertNestedInput: BracketUpsertNestedInputInputObject
      VoteUpdateManyMutationInput: VoteUpdateManyMutationInputInputObject
      UserCreateInput: UserCreateInputInputObject
      UserUpdateInput: UserUpdateInputInputObject
      UserUpdateManyMutationInput: UserUpdateManyMutationInputInputObject
      SongUpdateInput: SongUpdateInputInputObject
      SongUpdateManyMutationInput: SongUpdateManyMutationInputInputObject
      BracketUpdateInput: BracketUpdateInputInputObject
      BracketUpdateManyMutationInput: BracketUpdateManyMutationInputInputObject
      VoteSubscriptionWhereInput: VoteSubscriptionWhereInputInputObject
      UserSubscriptionWhereInput: UserSubscriptionWhereInputInputObject
      SongSubscriptionWhereInput: SongSubscriptionWhereInputInputObject
      BracketSubscriptionWhereInput: BracketSubscriptionWhereInputInputObject
    }
  }
  enumTypes: {
    VotingStatus: VotingStatusValues,
    VoteOrderByInput: VoteOrderByInputValues,
    BracketOrderByInput: BracketOrderByInputValues,
    SongOrderByInput: SongOrderByInputValues,
    UserOrderByInput: UserOrderByInputValues,
    MutationType: MutationTypeValues,
  }
}

// Types for Query

type QueryObject =
  | QueryFields
  | { name: 'vote', args?: QueryVoteArgs[] | false, alias?: string  } 
  | { name: 'votes', args?: QueryVotesArgs[] | false, alias?: string  } 
  | { name: 'votesConnection', args?: QueryVotesConnectionArgs[] | false, alias?: string  } 
  | { name: 'user', args?: QueryUserArgs[] | false, alias?: string  } 
  | { name: 'users', args?: QueryUsersArgs[] | false, alias?: string  } 
  | { name: 'usersConnection', args?: QueryUsersConnectionArgs[] | false, alias?: string  } 
  | { name: 'song', args?: QuerySongArgs[] | false, alias?: string  } 
  | { name: 'songs', args?: QuerySongsArgs[] | false, alias?: string  } 
  | { name: 'songsConnection', args?: QuerySongsConnectionArgs[] | false, alias?: string  } 
  | { name: 'bracket', args?: QueryBracketArgs[] | false, alias?: string  } 
  | { name: 'brackets', args?: QueryBracketsArgs[] | false, alias?: string  } 
  | { name: 'bracketsConnection', args?: QueryBracketsConnectionArgs[] | false, alias?: string  } 

type QueryFields =
  | 'vote'
  | 'votes'
  | 'votesConnection'
  | 'user'
  | 'users'
  | 'usersConnection'
  | 'song'
  | 'songs'
  | 'songsConnection'
  | 'bracket'
  | 'brackets'
  | 'bracketsConnection'


type QueryVoteArgs =
  | 'where'
type QueryVotesArgs =
  | 'where'
  | 'orderBy'
  | 'skip'
  | 'after'
  | 'before'
  | 'first'
  | 'last'
type QueryVotesConnectionArgs =
  | 'where'
  | 'orderBy'
  | 'skip'
  | 'after'
  | 'before'
  | 'first'
  | 'last'
type QueryUserArgs =
  | 'where'
type QueryUsersArgs =
  | 'where'
  | 'orderBy'
  | 'skip'
  | 'after'
  | 'before'
  | 'first'
  | 'last'
type QueryUsersConnectionArgs =
  | 'where'
  | 'orderBy'
  | 'skip'
  | 'after'
  | 'before'
  | 'first'
  | 'last'
type QuerySongArgs =
  | 'where'
type QuerySongsArgs =
  | 'where'
  | 'orderBy'
  | 'skip'
  | 'after'
  | 'before'
  | 'first'
  | 'last'
type QuerySongsConnectionArgs =
  | 'where'
  | 'orderBy'
  | 'skip'
  | 'after'
  | 'before'
  | 'first'
  | 'last'
type QueryBracketArgs =
  | 'where'
type QueryBracketsArgs =
  | 'where'
  | 'orderBy'
  | 'skip'
  | 'after'
  | 'before'
  | 'first'
  | 'last'
type QueryBracketsConnectionArgs =
  | 'where'
  | 'orderBy'
  | 'skip'
  | 'after'
  | 'before'
  | 'first'
  | 'last'
  

export interface QueryFieldDetails {
  vote: {
    type: 'Vote'
    args: Record<QueryVoteArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: true
    resolve: (
      root: core.RootValue<"Query">,
      args: { where: VoteWhereUniqueInput }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Vote | null> | prisma.Vote | null
  }
  votes: {
    type: 'Vote'
    args: Record<QueryVotesArgs, core.NexusArgDef<string>>
    description: string
    list: true
    nullable: false
    resolve: (
      root: core.RootValue<"Query">,
      args: { where?: VoteWhereInput | null, orderBy?: prisma.VoteOrderByInput | null, skip?: number | null, after?: string | null, before?: string | null, first?: number | null, last?: number | null }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Vote[]> | prisma.Vote[]
  }
  votesConnection: {
    type: 'VoteConnection'
    args: Record<QueryVotesConnectionArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"Query">,
      args: { where?: VoteWhereInput | null, orderBy?: prisma.VoteOrderByInput | null, skip?: number | null, after?: string | null, before?: string | null, first?: number | null, last?: number | null }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.VoteConnection> | prisma.VoteConnection
  }
  user: {
    type: 'User'
    args: Record<QueryUserArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: true
    resolve: (
      root: core.RootValue<"Query">,
      args: { where: UserWhereUniqueInput }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.User | null> | prisma.User | null
  }
  users: {
    type: 'User'
    args: Record<QueryUsersArgs, core.NexusArgDef<string>>
    description: string
    list: true
    nullable: false
    resolve: (
      root: core.RootValue<"Query">,
      args: { where?: UserWhereInput | null, orderBy?: prisma.UserOrderByInput | null, skip?: number | null, after?: string | null, before?: string | null, first?: number | null, last?: number | null }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.User[]> | prisma.User[]
  }
  usersConnection: {
    type: 'UserConnection'
    args: Record<QueryUsersConnectionArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"Query">,
      args: { where?: UserWhereInput | null, orderBy?: prisma.UserOrderByInput | null, skip?: number | null, after?: string | null, before?: string | null, first?: number | null, last?: number | null }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.UserConnection> | prisma.UserConnection
  }
  song: {
    type: 'Song'
    args: Record<QuerySongArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: true
    resolve: (
      root: core.RootValue<"Query">,
      args: { where: SongWhereUniqueInput }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Song | null> | prisma.Song | null
  }
  songs: {
    type: 'Song'
    args: Record<QuerySongsArgs, core.NexusArgDef<string>>
    description: string
    list: true
    nullable: false
    resolve: (
      root: core.RootValue<"Query">,
      args: { where?: SongWhereInput | null, orderBy?: prisma.SongOrderByInput | null, skip?: number | null, after?: string | null, before?: string | null, first?: number | null, last?: number | null }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Song[]> | prisma.Song[]
  }
  songsConnection: {
    type: 'SongConnection'
    args: Record<QuerySongsConnectionArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"Query">,
      args: { where?: SongWhereInput | null, orderBy?: prisma.SongOrderByInput | null, skip?: number | null, after?: string | null, before?: string | null, first?: number | null, last?: number | null }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.SongConnection> | prisma.SongConnection
  }
  bracket: {
    type: 'Bracket'
    args: Record<QueryBracketArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: true
    resolve: (
      root: core.RootValue<"Query">,
      args: { where: BracketWhereUniqueInput }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Bracket | null> | prisma.Bracket | null
  }
  brackets: {
    type: 'Bracket'
    args: Record<QueryBracketsArgs, core.NexusArgDef<string>>
    description: string
    list: true
    nullable: false
    resolve: (
      root: core.RootValue<"Query">,
      args: { where?: BracketWhereInput | null, orderBy?: prisma.BracketOrderByInput | null, skip?: number | null, after?: string | null, before?: string | null, first?: number | null, last?: number | null }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Bracket[]> | prisma.Bracket[]
  }
  bracketsConnection: {
    type: 'BracketConnection'
    args: Record<QueryBracketsConnectionArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"Query">,
      args: { where?: BracketWhereInput | null, orderBy?: prisma.BracketOrderByInput | null, skip?: number | null, after?: string | null, before?: string | null, first?: number | null, last?: number | null }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.BracketConnection> | prisma.BracketConnection
  }
}
  

// Types for Vote

type VoteObject =
  | VoteFields
  | { name: 'id', args?: [] | false, alias?: string  } 
  | { name: 'voteType', args?: [] | false, alias?: string  } 
  | { name: 'song', args?: [] | false, alias?: string  } 
  | { name: 'bracket', args?: [] | false, alias?: string  } 
  | { name: 'user', args?: [] | false, alias?: string  } 

type VoteFields =
  | 'id'
  | 'voteType'
  | 'song'
  | 'bracket'
  | 'user'



  

export interface VoteFieldDetails {
  id: {
    type: 'ID'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
  voteType: {
    type: 'Boolean'
    args: {}
    description: string
    list: undefined
    nullable: true
    resolve: undefined
  }
  song: {
    type: 'Song'
    args: {}
    description: string
    list: undefined
    nullable: true
    resolve: (
      root: core.RootValue<"Vote">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Song | null> | prisma.Song | null
  }
  bracket: {
    type: 'Bracket'
    args: {}
    description: string
    list: undefined
    nullable: true
    resolve: (
      root: core.RootValue<"Vote">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Bracket | null> | prisma.Bracket | null
  }
  user: {
    type: 'User'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"Vote">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.User> | prisma.User
  }
}
  

// Types for Song

type SongObject =
  | SongFields
  | { name: 'id', args?: [] | false, alias?: string  } 
  | { name: 'spotifyID', args?: [] | false, alias?: string  } 
  | { name: 'title', args?: [] | false, alias?: string  } 
  | { name: 'album', args?: [] | false, alias?: string  } 
  | { name: 'position', args?: [] | false, alias?: string  } 
  | { name: 'votingStatus', args?: [] | false, alias?: string  } 
  | { name: 'votes', args?: SongVotesArgs[] | false, alias?: string  } 

type SongFields =
  | 'id'
  | 'spotifyID'
  | 'title'
  | 'album'
  | 'position'
  | 'votingStatus'
  | 'votes'


type SongVotesArgs =
  | 'where'
  | 'orderBy'
  | 'skip'
  | 'after'
  | 'before'
  | 'first'
  | 'last'
  

export interface SongFieldDetails {
  id: {
    type: 'ID'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
  spotifyID: {
    type: 'String'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
  title: {
    type: 'String'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
  album: {
    type: 'String'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
  position: {
    type: 'Int'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
  votingStatus: {
    type: 'VotingStatus'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"Song">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.VotingStatus> | prisma.VotingStatus
  }
  votes: {
    type: 'Vote'
    args: Record<SongVotesArgs, core.NexusArgDef<string>>
    description: string
    list: true
    nullable: false
    resolve: (
      root: core.RootValue<"Song">,
      args: { where?: VoteWhereInput | null, orderBy?: prisma.VoteOrderByInput | null, skip?: number | null, after?: string | null, before?: string | null, first?: number | null, last?: number | null }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Vote[]> | prisma.Vote[]
  }
}
  

// Types for Bracket

type BracketObject =
  | BracketFields
  | { name: 'id', args?: [] | false, alias?: string  } 
  | { name: 'user', args?: [] | false, alias?: string  } 
  | { name: 'songs', args?: BracketSongsArgs[] | false, alias?: string  } 
  | { name: 'roundTime', args?: [] | false, alias?: string  } 
  | { name: 'active', args?: [] | false, alias?: string  } 

type BracketFields =
  | 'id'
  | 'user'
  | 'songs'
  | 'roundTime'
  | 'active'


type BracketSongsArgs =
  | 'where'
  | 'orderBy'
  | 'skip'
  | 'after'
  | 'before'
  | 'first'
  | 'last'
  

export interface BracketFieldDetails {
  id: {
    type: 'ID'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
  user: {
    type: 'User'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"Bracket">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.User> | prisma.User
  }
  songs: {
    type: 'Song'
    args: Record<BracketSongsArgs, core.NexusArgDef<string>>
    description: string
    list: true
    nullable: false
    resolve: (
      root: core.RootValue<"Bracket">,
      args: { where?: SongWhereInput | null, orderBy?: prisma.SongOrderByInput | null, skip?: number | null, after?: string | null, before?: string | null, first?: number | null, last?: number | null }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Song[]> | prisma.Song[]
  }
  roundTime: {
    type: 'Int'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
  active: {
    type: 'Boolean'
    args: {}
    description: string
    list: undefined
    nullable: true
    resolve: undefined
  }
}
  

// Types for User

type UserObject =
  | UserFields
  | { name: 'id', args?: [] | false, alias?: string  } 
  | { name: 'username', args?: [] | false, alias?: string  } 
  | { name: 'email', args?: [] | false, alias?: string  } 
  | { name: 'password', args?: [] | false, alias?: string  } 
  | { name: 'votes', args?: UserVotesArgs[] | false, alias?: string  } 
  | { name: 'brackets', args?: UserBracketsArgs[] | false, alias?: string  } 

type UserFields =
  | 'id'
  | 'username'
  | 'email'
  | 'password'
  | 'votes'
  | 'brackets'


type UserVotesArgs =
  | 'where'
  | 'orderBy'
  | 'skip'
  | 'after'
  | 'before'
  | 'first'
  | 'last'
type UserBracketsArgs =
  | 'where'
  | 'orderBy'
  | 'skip'
  | 'after'
  | 'before'
  | 'first'
  | 'last'
  

export interface UserFieldDetails {
  id: {
    type: 'ID'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
  username: {
    type: 'String'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
  email: {
    type: 'String'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
  password: {
    type: 'String'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
  votes: {
    type: 'Vote'
    args: Record<UserVotesArgs, core.NexusArgDef<string>>
    description: string
    list: true
    nullable: false
    resolve: (
      root: core.RootValue<"User">,
      args: { where?: VoteWhereInput | null, orderBy?: prisma.VoteOrderByInput | null, skip?: number | null, after?: string | null, before?: string | null, first?: number | null, last?: number | null }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Vote[]> | prisma.Vote[]
  }
  brackets: {
    type: 'Bracket'
    args: Record<UserBracketsArgs, core.NexusArgDef<string>>
    description: string
    list: true
    nullable: false
    resolve: (
      root: core.RootValue<"User">,
      args: { where?: BracketWhereInput | null, orderBy?: prisma.BracketOrderByInput | null, skip?: number | null, after?: string | null, before?: string | null, first?: number | null, last?: number | null }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Bracket[]> | prisma.Bracket[]
  }
}
  

// Types for VoteConnection

type VoteConnectionObject =
  | VoteConnectionFields
  | { name: 'pageInfo', args?: [] | false, alias?: string  } 
  | { name: 'edges', args?: [] | false, alias?: string  } 
  | { name: 'aggregate', args?: [] | false, alias?: string  } 

type VoteConnectionFields =
  | 'pageInfo'
  | 'edges'
  | 'aggregate'



  

export interface VoteConnectionFieldDetails {
  pageInfo: {
    type: 'PageInfo'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"VoteConnection">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.PageInfo> | prisma.PageInfo
  }
  edges: {
    type: 'VoteEdge'
    args: {}
    description: string
    list: true
    nullable: false
    resolve: (
      root: core.RootValue<"VoteConnection">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.VoteEdge[]> | prisma.VoteEdge[]
  }
  aggregate: {
    type: 'AggregateVote'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"VoteConnection">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.AggregateVote> | prisma.AggregateVote
  }
}
  

// Types for PageInfo

type PageInfoObject =
  | PageInfoFields
  | { name: 'hasNextPage', args?: [] | false, alias?: string  } 
  | { name: 'hasPreviousPage', args?: [] | false, alias?: string  } 
  | { name: 'startCursor', args?: [] | false, alias?: string  } 
  | { name: 'endCursor', args?: [] | false, alias?: string  } 

type PageInfoFields =
  | 'hasNextPage'
  | 'hasPreviousPage'
  | 'startCursor'
  | 'endCursor'



  

export interface PageInfoFieldDetails {
  hasNextPage: {
    type: 'Boolean'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
  hasPreviousPage: {
    type: 'Boolean'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
  startCursor: {
    type: 'String'
    args: {}
    description: string
    list: undefined
    nullable: true
    resolve: undefined
  }
  endCursor: {
    type: 'String'
    args: {}
    description: string
    list: undefined
    nullable: true
    resolve: undefined
  }
}
  

// Types for VoteEdge

type VoteEdgeObject =
  | VoteEdgeFields
  | { name: 'node', args?: [] | false, alias?: string  } 
  | { name: 'cursor', args?: [] | false, alias?: string  } 

type VoteEdgeFields =
  | 'node'
  | 'cursor'



  

export interface VoteEdgeFieldDetails {
  node: {
    type: 'Vote'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"VoteEdge">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Vote> | prisma.Vote
  }
  cursor: {
    type: 'String'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
}
  

// Types for AggregateVote

type AggregateVoteObject =
  | AggregateVoteFields
  | { name: 'count', args?: [] | false, alias?: string  } 

type AggregateVoteFields =
  | 'count'



  

export interface AggregateVoteFieldDetails {
  count: {
    type: 'Int'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
}
  

// Types for UserConnection

type UserConnectionObject =
  | UserConnectionFields
  | { name: 'pageInfo', args?: [] | false, alias?: string  } 
  | { name: 'edges', args?: [] | false, alias?: string  } 
  | { name: 'aggregate', args?: [] | false, alias?: string  } 

type UserConnectionFields =
  | 'pageInfo'
  | 'edges'
  | 'aggregate'



  

export interface UserConnectionFieldDetails {
  pageInfo: {
    type: 'PageInfo'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"UserConnection">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.PageInfo> | prisma.PageInfo
  }
  edges: {
    type: 'UserEdge'
    args: {}
    description: string
    list: true
    nullable: false
    resolve: (
      root: core.RootValue<"UserConnection">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.UserEdge[]> | prisma.UserEdge[]
  }
  aggregate: {
    type: 'AggregateUser'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"UserConnection">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.AggregateUser> | prisma.AggregateUser
  }
}
  

// Types for UserEdge

type UserEdgeObject =
  | UserEdgeFields
  | { name: 'node', args?: [] | false, alias?: string  } 
  | { name: 'cursor', args?: [] | false, alias?: string  } 

type UserEdgeFields =
  | 'node'
  | 'cursor'



  

export interface UserEdgeFieldDetails {
  node: {
    type: 'User'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"UserEdge">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.User> | prisma.User
  }
  cursor: {
    type: 'String'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
}
  

// Types for AggregateUser

type AggregateUserObject =
  | AggregateUserFields
  | { name: 'count', args?: [] | false, alias?: string  } 

type AggregateUserFields =
  | 'count'



  

export interface AggregateUserFieldDetails {
  count: {
    type: 'Int'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
}
  

// Types for SongConnection

type SongConnectionObject =
  | SongConnectionFields
  | { name: 'pageInfo', args?: [] | false, alias?: string  } 
  | { name: 'edges', args?: [] | false, alias?: string  } 
  | { name: 'aggregate', args?: [] | false, alias?: string  } 

type SongConnectionFields =
  | 'pageInfo'
  | 'edges'
  | 'aggregate'



  

export interface SongConnectionFieldDetails {
  pageInfo: {
    type: 'PageInfo'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"SongConnection">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.PageInfo> | prisma.PageInfo
  }
  edges: {
    type: 'SongEdge'
    args: {}
    description: string
    list: true
    nullable: false
    resolve: (
      root: core.RootValue<"SongConnection">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.SongEdge[]> | prisma.SongEdge[]
  }
  aggregate: {
    type: 'AggregateSong'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"SongConnection">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.AggregateSong> | prisma.AggregateSong
  }
}
  

// Types for SongEdge

type SongEdgeObject =
  | SongEdgeFields
  | { name: 'node', args?: [] | false, alias?: string  } 
  | { name: 'cursor', args?: [] | false, alias?: string  } 

type SongEdgeFields =
  | 'node'
  | 'cursor'



  

export interface SongEdgeFieldDetails {
  node: {
    type: 'Song'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"SongEdge">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Song> | prisma.Song
  }
  cursor: {
    type: 'String'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
}
  

// Types for AggregateSong

type AggregateSongObject =
  | AggregateSongFields
  | { name: 'count', args?: [] | false, alias?: string  } 

type AggregateSongFields =
  | 'count'



  

export interface AggregateSongFieldDetails {
  count: {
    type: 'Int'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
}
  

// Types for BracketConnection

type BracketConnectionObject =
  | BracketConnectionFields
  | { name: 'pageInfo', args?: [] | false, alias?: string  } 
  | { name: 'edges', args?: [] | false, alias?: string  } 
  | { name: 'aggregate', args?: [] | false, alias?: string  } 

type BracketConnectionFields =
  | 'pageInfo'
  | 'edges'
  | 'aggregate'



  

export interface BracketConnectionFieldDetails {
  pageInfo: {
    type: 'PageInfo'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"BracketConnection">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.PageInfo> | prisma.PageInfo
  }
  edges: {
    type: 'BracketEdge'
    args: {}
    description: string
    list: true
    nullable: false
    resolve: (
      root: core.RootValue<"BracketConnection">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.BracketEdge[]> | prisma.BracketEdge[]
  }
  aggregate: {
    type: 'AggregateBracket'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"BracketConnection">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.AggregateBracket> | prisma.AggregateBracket
  }
}
  

// Types for BracketEdge

type BracketEdgeObject =
  | BracketEdgeFields
  | { name: 'node', args?: [] | false, alias?: string  } 
  | { name: 'cursor', args?: [] | false, alias?: string  } 

type BracketEdgeFields =
  | 'node'
  | 'cursor'



  

export interface BracketEdgeFieldDetails {
  node: {
    type: 'Bracket'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"BracketEdge">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Bracket> | prisma.Bracket
  }
  cursor: {
    type: 'String'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
}
  

// Types for AggregateBracket

type AggregateBracketObject =
  | AggregateBracketFields
  | { name: 'count', args?: [] | false, alias?: string  } 

type AggregateBracketFields =
  | 'count'



  

export interface AggregateBracketFieldDetails {
  count: {
    type: 'Int'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
}
  

// Types for Mutation

type MutationObject =
  | MutationFields
  | { name: 'createVote', args?: MutationCreateVoteArgs[] | false, alias?: string  } 
  | { name: 'updateVote', args?: MutationUpdateVoteArgs[] | false, alias?: string  } 
  | { name: 'updateManyVotes', args?: MutationUpdateManyVotesArgs[] | false, alias?: string  } 
  | { name: 'upsertVote', args?: MutationUpsertVoteArgs[] | false, alias?: string  } 
  | { name: 'deleteVote', args?: MutationDeleteVoteArgs[] | false, alias?: string  } 
  | { name: 'deleteManyVotes', args?: MutationDeleteManyVotesArgs[] | false, alias?: string  } 
  | { name: 'createUser', args?: MutationCreateUserArgs[] | false, alias?: string  } 
  | { name: 'updateUser', args?: MutationUpdateUserArgs[] | false, alias?: string  } 
  | { name: 'updateManyUsers', args?: MutationUpdateManyUsersArgs[] | false, alias?: string  } 
  | { name: 'upsertUser', args?: MutationUpsertUserArgs[] | false, alias?: string  } 
  | { name: 'deleteUser', args?: MutationDeleteUserArgs[] | false, alias?: string  } 
  | { name: 'deleteManyUsers', args?: MutationDeleteManyUsersArgs[] | false, alias?: string  } 
  | { name: 'createSong', args?: MutationCreateSongArgs[] | false, alias?: string  } 
  | { name: 'updateSong', args?: MutationUpdateSongArgs[] | false, alias?: string  } 
  | { name: 'updateManySongs', args?: MutationUpdateManySongsArgs[] | false, alias?: string  } 
  | { name: 'upsertSong', args?: MutationUpsertSongArgs[] | false, alias?: string  } 
  | { name: 'deleteSong', args?: MutationDeleteSongArgs[] | false, alias?: string  } 
  | { name: 'deleteManySongs', args?: MutationDeleteManySongsArgs[] | false, alias?: string  } 
  | { name: 'createBracket', args?: MutationCreateBracketArgs[] | false, alias?: string  } 
  | { name: 'updateBracket', args?: MutationUpdateBracketArgs[] | false, alias?: string  } 
  | { name: 'updateManyBrackets', args?: MutationUpdateManyBracketsArgs[] | false, alias?: string  } 
  | { name: 'upsertBracket', args?: MutationUpsertBracketArgs[] | false, alias?: string  } 
  | { name: 'deleteBracket', args?: MutationDeleteBracketArgs[] | false, alias?: string  } 
  | { name: 'deleteManyBrackets', args?: MutationDeleteManyBracketsArgs[] | false, alias?: string  } 

type MutationFields =
  | 'createVote'
  | 'updateVote'
  | 'updateManyVotes'
  | 'upsertVote'
  | 'deleteVote'
  | 'deleteManyVotes'
  | 'createUser'
  | 'updateUser'
  | 'updateManyUsers'
  | 'upsertUser'
  | 'deleteUser'
  | 'deleteManyUsers'
  | 'createSong'
  | 'updateSong'
  | 'updateManySongs'
  | 'upsertSong'
  | 'deleteSong'
  | 'deleteManySongs'
  | 'createBracket'
  | 'updateBracket'
  | 'updateManyBrackets'
  | 'upsertBracket'
  | 'deleteBracket'
  | 'deleteManyBrackets'


type MutationCreateVoteArgs =
  | 'data'
type MutationUpdateVoteArgs =
  | 'data'
  | 'where'
type MutationUpdateManyVotesArgs =
  | 'data'
  | 'where'
type MutationUpsertVoteArgs =
  | 'where'
  | 'create'
  | 'update'
type MutationDeleteVoteArgs =
  | 'where'
type MutationDeleteManyVotesArgs =
  | 'where'
type MutationCreateUserArgs =
  | 'data'
type MutationUpdateUserArgs =
  | 'data'
  | 'where'
type MutationUpdateManyUsersArgs =
  | 'data'
  | 'where'
type MutationUpsertUserArgs =
  | 'where'
  | 'create'
  | 'update'
type MutationDeleteUserArgs =
  | 'where'
type MutationDeleteManyUsersArgs =
  | 'where'
type MutationCreateSongArgs =
  | 'data'
type MutationUpdateSongArgs =
  | 'data'
  | 'where'
type MutationUpdateManySongsArgs =
  | 'data'
  | 'where'
type MutationUpsertSongArgs =
  | 'where'
  | 'create'
  | 'update'
type MutationDeleteSongArgs =
  | 'where'
type MutationDeleteManySongsArgs =
  | 'where'
type MutationCreateBracketArgs =
  | 'data'
type MutationUpdateBracketArgs =
  | 'data'
  | 'where'
type MutationUpdateManyBracketsArgs =
  | 'data'
  | 'where'
type MutationUpsertBracketArgs =
  | 'where'
  | 'create'
  | 'update'
type MutationDeleteBracketArgs =
  | 'where'
type MutationDeleteManyBracketsArgs =
  | 'where'
  

export interface MutationFieldDetails {
  createVote: {
    type: 'Vote'
    args: Record<MutationCreateVoteArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"Mutation">,
      args: { data: VoteCreateInput }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Vote> | prisma.Vote
  }
  updateVote: {
    type: 'Vote'
    args: Record<MutationUpdateVoteArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: true
    resolve: (
      root: core.RootValue<"Mutation">,
      args: { data: VoteUpdateInput, where: VoteWhereUniqueInput }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Vote | null> | prisma.Vote | null
  }
  updateManyVotes: {
    type: 'BatchPayload'
    args: Record<MutationUpdateManyVotesArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"Mutation">,
      args: { data: VoteUpdateManyMutationInput, where?: VoteWhereInput | null }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.BatchPayload> | prisma.BatchPayload
  }
  upsertVote: {
    type: 'Vote'
    args: Record<MutationUpsertVoteArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"Mutation">,
      args: { where: VoteWhereUniqueInput, create: VoteCreateInput, update: VoteUpdateInput }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Vote> | prisma.Vote
  }
  deleteVote: {
    type: 'Vote'
    args: Record<MutationDeleteVoteArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: true
    resolve: (
      root: core.RootValue<"Mutation">,
      args: { where: VoteWhereUniqueInput }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Vote | null> | prisma.Vote | null
  }
  deleteManyVotes: {
    type: 'BatchPayload'
    args: Record<MutationDeleteManyVotesArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"Mutation">,
      args: { where?: VoteWhereInput | null }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.BatchPayload> | prisma.BatchPayload
  }
  createUser: {
    type: 'User'
    args: Record<MutationCreateUserArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"Mutation">,
      args: { data: UserCreateInput }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.User> | prisma.User
  }
  updateUser: {
    type: 'User'
    args: Record<MutationUpdateUserArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: true
    resolve: (
      root: core.RootValue<"Mutation">,
      args: { data: UserUpdateInput, where: UserWhereUniqueInput }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.User | null> | prisma.User | null
  }
  updateManyUsers: {
    type: 'BatchPayload'
    args: Record<MutationUpdateManyUsersArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"Mutation">,
      args: { data: UserUpdateManyMutationInput, where?: UserWhereInput | null }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.BatchPayload> | prisma.BatchPayload
  }
  upsertUser: {
    type: 'User'
    args: Record<MutationUpsertUserArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"Mutation">,
      args: { where: UserWhereUniqueInput, create: UserCreateInput, update: UserUpdateInput }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.User> | prisma.User
  }
  deleteUser: {
    type: 'User'
    args: Record<MutationDeleteUserArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: true
    resolve: (
      root: core.RootValue<"Mutation">,
      args: { where: UserWhereUniqueInput }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.User | null> | prisma.User | null
  }
  deleteManyUsers: {
    type: 'BatchPayload'
    args: Record<MutationDeleteManyUsersArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"Mutation">,
      args: { where?: UserWhereInput | null }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.BatchPayload> | prisma.BatchPayload
  }
  createSong: {
    type: 'Song'
    args: Record<MutationCreateSongArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"Mutation">,
      args: { data: SongCreateInput }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Song> | prisma.Song
  }
  updateSong: {
    type: 'Song'
    args: Record<MutationUpdateSongArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: true
    resolve: (
      root: core.RootValue<"Mutation">,
      args: { data: SongUpdateInput, where: SongWhereUniqueInput }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Song | null> | prisma.Song | null
  }
  updateManySongs: {
    type: 'BatchPayload'
    args: Record<MutationUpdateManySongsArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"Mutation">,
      args: { data: SongUpdateManyMutationInput, where?: SongWhereInput | null }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.BatchPayload> | prisma.BatchPayload
  }
  upsertSong: {
    type: 'Song'
    args: Record<MutationUpsertSongArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"Mutation">,
      args: { where: SongWhereUniqueInput, create: SongCreateInput, update: SongUpdateInput }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Song> | prisma.Song
  }
  deleteSong: {
    type: 'Song'
    args: Record<MutationDeleteSongArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: true
    resolve: (
      root: core.RootValue<"Mutation">,
      args: { where: SongWhereUniqueInput }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Song | null> | prisma.Song | null
  }
  deleteManySongs: {
    type: 'BatchPayload'
    args: Record<MutationDeleteManySongsArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"Mutation">,
      args: { where?: SongWhereInput | null }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.BatchPayload> | prisma.BatchPayload
  }
  createBracket: {
    type: 'Bracket'
    args: Record<MutationCreateBracketArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"Mutation">,
      args: { data: BracketCreateInput }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Bracket> | prisma.Bracket
  }
  updateBracket: {
    type: 'Bracket'
    args: Record<MutationUpdateBracketArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: true
    resolve: (
      root: core.RootValue<"Mutation">,
      args: { data: BracketUpdateInput, where: BracketWhereUniqueInput }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Bracket | null> | prisma.Bracket | null
  }
  updateManyBrackets: {
    type: 'BatchPayload'
    args: Record<MutationUpdateManyBracketsArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"Mutation">,
      args: { data: BracketUpdateManyMutationInput, where?: BracketWhereInput | null }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.BatchPayload> | prisma.BatchPayload
  }
  upsertBracket: {
    type: 'Bracket'
    args: Record<MutationUpsertBracketArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"Mutation">,
      args: { where: BracketWhereUniqueInput, create: BracketCreateInput, update: BracketUpdateInput }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Bracket> | prisma.Bracket
  }
  deleteBracket: {
    type: 'Bracket'
    args: Record<MutationDeleteBracketArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: true
    resolve: (
      root: core.RootValue<"Mutation">,
      args: { where: BracketWhereUniqueInput }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Bracket | null> | prisma.Bracket | null
  }
  deleteManyBrackets: {
    type: 'BatchPayload'
    args: Record<MutationDeleteManyBracketsArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"Mutation">,
      args: { where?: BracketWhereInput | null }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.BatchPayload> | prisma.BatchPayload
  }
}
  

// Types for BatchPayload

type BatchPayloadObject =
  | BatchPayloadFields
  | { name: 'count', args?: [] | false, alias?: string  } 

type BatchPayloadFields =
  | 'count'



  

export interface BatchPayloadFieldDetails {
  count: {
    type: 'Long'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
}
  

// Types for Subscription

type SubscriptionObject =
  | SubscriptionFields
  | { name: 'vote', args?: SubscriptionVoteArgs[] | false, alias?: string  } 
  | { name: 'user', args?: SubscriptionUserArgs[] | false, alias?: string  } 
  | { name: 'song', args?: SubscriptionSongArgs[] | false, alias?: string  } 
  | { name: 'bracket', args?: SubscriptionBracketArgs[] | false, alias?: string  } 

type SubscriptionFields =
  | 'vote'
  | 'user'
  | 'song'
  | 'bracket'


type SubscriptionVoteArgs =
  | 'where'
type SubscriptionUserArgs =
  | 'where'
type SubscriptionSongArgs =
  | 'where'
type SubscriptionBracketArgs =
  | 'where'
  

export interface SubscriptionFieldDetails {
  vote: {
    type: 'VoteSubscriptionPayload'
    args: Record<SubscriptionVoteArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: true
    resolve: (
      root: core.RootValue<"Subscription">,
      args: { where?: VoteSubscriptionWhereInput | null }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.VoteSubscriptionPayload | null> | prisma.VoteSubscriptionPayload | null
  }
  user: {
    type: 'UserSubscriptionPayload'
    args: Record<SubscriptionUserArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: true
    resolve: (
      root: core.RootValue<"Subscription">,
      args: { where?: UserSubscriptionWhereInput | null }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.UserSubscriptionPayload | null> | prisma.UserSubscriptionPayload | null
  }
  song: {
    type: 'SongSubscriptionPayload'
    args: Record<SubscriptionSongArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: true
    resolve: (
      root: core.RootValue<"Subscription">,
      args: { where?: SongSubscriptionWhereInput | null }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.SongSubscriptionPayload | null> | prisma.SongSubscriptionPayload | null
  }
  bracket: {
    type: 'BracketSubscriptionPayload'
    args: Record<SubscriptionBracketArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: true
    resolve: (
      root: core.RootValue<"Subscription">,
      args: { where?: BracketSubscriptionWhereInput | null }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.BracketSubscriptionPayload | null> | prisma.BracketSubscriptionPayload | null
  }
}
  

// Types for VoteSubscriptionPayload

type VoteSubscriptionPayloadObject =
  | VoteSubscriptionPayloadFields
  | { name: 'mutation', args?: [] | false, alias?: string  } 
  | { name: 'node', args?: [] | false, alias?: string  } 
  | { name: 'updatedFields', args?: [] | false, alias?: string  } 
  | { name: 'previousValues', args?: [] | false, alias?: string  } 

type VoteSubscriptionPayloadFields =
  | 'mutation'
  | 'node'
  | 'updatedFields'
  | 'previousValues'



  

export interface VoteSubscriptionPayloadFieldDetails {
  mutation: {
    type: 'MutationType'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"VoteSubscriptionPayload">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.MutationType> | prisma.MutationType
  }
  node: {
    type: 'Vote'
    args: {}
    description: string
    list: undefined
    nullable: true
    resolve: (
      root: core.RootValue<"VoteSubscriptionPayload">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Vote | null> | prisma.Vote | null
  }
  updatedFields: {
    type: 'String'
    args: {}
    description: string
    list: true
    nullable: false
    resolve: undefined
  }
  previousValues: {
    type: 'VotePreviousValues'
    args: {}
    description: string
    list: undefined
    nullable: true
    resolve: (
      root: core.RootValue<"VoteSubscriptionPayload">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.VotePreviousValues | null> | prisma.VotePreviousValues | null
  }
}
  

// Types for VotePreviousValues

type VotePreviousValuesObject =
  | VotePreviousValuesFields
  | { name: 'id', args?: [] | false, alias?: string  } 
  | { name: 'voteType', args?: [] | false, alias?: string  } 

type VotePreviousValuesFields =
  | 'id'
  | 'voteType'



  

export interface VotePreviousValuesFieldDetails {
  id: {
    type: 'ID'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
  voteType: {
    type: 'Boolean'
    args: {}
    description: string
    list: undefined
    nullable: true
    resolve: undefined
  }
}
  

// Types for UserSubscriptionPayload

type UserSubscriptionPayloadObject =
  | UserSubscriptionPayloadFields
  | { name: 'mutation', args?: [] | false, alias?: string  } 
  | { name: 'node', args?: [] | false, alias?: string  } 
  | { name: 'updatedFields', args?: [] | false, alias?: string  } 
  | { name: 'previousValues', args?: [] | false, alias?: string  } 

type UserSubscriptionPayloadFields =
  | 'mutation'
  | 'node'
  | 'updatedFields'
  | 'previousValues'



  

export interface UserSubscriptionPayloadFieldDetails {
  mutation: {
    type: 'MutationType'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"UserSubscriptionPayload">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.MutationType> | prisma.MutationType
  }
  node: {
    type: 'User'
    args: {}
    description: string
    list: undefined
    nullable: true
    resolve: (
      root: core.RootValue<"UserSubscriptionPayload">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.User | null> | prisma.User | null
  }
  updatedFields: {
    type: 'String'
    args: {}
    description: string
    list: true
    nullable: false
    resolve: undefined
  }
  previousValues: {
    type: 'UserPreviousValues'
    args: {}
    description: string
    list: undefined
    nullable: true
    resolve: (
      root: core.RootValue<"UserSubscriptionPayload">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.UserPreviousValues | null> | prisma.UserPreviousValues | null
  }
}
  

// Types for UserPreviousValues

type UserPreviousValuesObject =
  | UserPreviousValuesFields
  | { name: 'id', args?: [] | false, alias?: string  } 
  | { name: 'username', args?: [] | false, alias?: string  } 
  | { name: 'email', args?: [] | false, alias?: string  } 
  | { name: 'password', args?: [] | false, alias?: string  } 

type UserPreviousValuesFields =
  | 'id'
  | 'username'
  | 'email'
  | 'password'



  

export interface UserPreviousValuesFieldDetails {
  id: {
    type: 'ID'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
  username: {
    type: 'String'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
  email: {
    type: 'String'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
  password: {
    type: 'String'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
}
  

// Types for SongSubscriptionPayload

type SongSubscriptionPayloadObject =
  | SongSubscriptionPayloadFields
  | { name: 'mutation', args?: [] | false, alias?: string  } 
  | { name: 'node', args?: [] | false, alias?: string  } 
  | { name: 'updatedFields', args?: [] | false, alias?: string  } 
  | { name: 'previousValues', args?: [] | false, alias?: string  } 

type SongSubscriptionPayloadFields =
  | 'mutation'
  | 'node'
  | 'updatedFields'
  | 'previousValues'



  

export interface SongSubscriptionPayloadFieldDetails {
  mutation: {
    type: 'MutationType'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"SongSubscriptionPayload">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.MutationType> | prisma.MutationType
  }
  node: {
    type: 'Song'
    args: {}
    description: string
    list: undefined
    nullable: true
    resolve: (
      root: core.RootValue<"SongSubscriptionPayload">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Song | null> | prisma.Song | null
  }
  updatedFields: {
    type: 'String'
    args: {}
    description: string
    list: true
    nullable: false
    resolve: undefined
  }
  previousValues: {
    type: 'SongPreviousValues'
    args: {}
    description: string
    list: undefined
    nullable: true
    resolve: (
      root: core.RootValue<"SongSubscriptionPayload">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.SongPreviousValues | null> | prisma.SongPreviousValues | null
  }
}
  

// Types for SongPreviousValues

type SongPreviousValuesObject =
  | SongPreviousValuesFields
  | { name: 'id', args?: [] | false, alias?: string  } 
  | { name: 'spotifyID', args?: [] | false, alias?: string  } 
  | { name: 'title', args?: [] | false, alias?: string  } 
  | { name: 'album', args?: [] | false, alias?: string  } 
  | { name: 'position', args?: [] | false, alias?: string  } 
  | { name: 'votingStatus', args?: [] | false, alias?: string  } 

type SongPreviousValuesFields =
  | 'id'
  | 'spotifyID'
  | 'title'
  | 'album'
  | 'position'
  | 'votingStatus'



  

export interface SongPreviousValuesFieldDetails {
  id: {
    type: 'ID'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
  spotifyID: {
    type: 'String'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
  title: {
    type: 'String'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
  album: {
    type: 'String'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
  position: {
    type: 'Int'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
  votingStatus: {
    type: 'VotingStatus'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"SongPreviousValues">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.VotingStatus> | prisma.VotingStatus
  }
}
  

// Types for BracketSubscriptionPayload

type BracketSubscriptionPayloadObject =
  | BracketSubscriptionPayloadFields
  | { name: 'mutation', args?: [] | false, alias?: string  } 
  | { name: 'node', args?: [] | false, alias?: string  } 
  | { name: 'updatedFields', args?: [] | false, alias?: string  } 
  | { name: 'previousValues', args?: [] | false, alias?: string  } 

type BracketSubscriptionPayloadFields =
  | 'mutation'
  | 'node'
  | 'updatedFields'
  | 'previousValues'



  

export interface BracketSubscriptionPayloadFieldDetails {
  mutation: {
    type: 'MutationType'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"BracketSubscriptionPayload">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.MutationType> | prisma.MutationType
  }
  node: {
    type: 'Bracket'
    args: {}
    description: string
    list: undefined
    nullable: true
    resolve: (
      root: core.RootValue<"BracketSubscriptionPayload">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Bracket | null> | prisma.Bracket | null
  }
  updatedFields: {
    type: 'String'
    args: {}
    description: string
    list: true
    nullable: false
    resolve: undefined
  }
  previousValues: {
    type: 'BracketPreviousValues'
    args: {}
    description: string
    list: undefined
    nullable: true
    resolve: (
      root: core.RootValue<"BracketSubscriptionPayload">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.BracketPreviousValues | null> | prisma.BracketPreviousValues | null
  }
}
  

// Types for BracketPreviousValues

type BracketPreviousValuesObject =
  | BracketPreviousValuesFields
  | { name: 'id', args?: [] | false, alias?: string  } 
  | { name: 'roundTime', args?: [] | false, alias?: string  } 
  | { name: 'active', args?: [] | false, alias?: string  } 

type BracketPreviousValuesFields =
  | 'id'
  | 'roundTime'
  | 'active'



  

export interface BracketPreviousValuesFieldDetails {
  id: {
    type: 'ID'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
  roundTime: {
    type: 'Int'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
  active: {
    type: 'Boolean'
    args: {}
    description: string
    list: undefined
    nullable: true
    resolve: undefined
  }
}
  


export interface VoteWhereUniqueInput {
  id?: string | null
}
export type VoteWhereUniqueInputInputObject =
  | Extract<keyof VoteWhereUniqueInput, string>
  | { name: 'id', alias?: string  } 
  
export interface VoteWhereInput {
  id?: string | null
  id_not?: string | null
  id_in?: string[]
  id_not_in?: string[]
  id_lt?: string | null
  id_lte?: string | null
  id_gt?: string | null
  id_gte?: string | null
  id_contains?: string | null
  id_not_contains?: string | null
  id_starts_with?: string | null
  id_not_starts_with?: string | null
  id_ends_with?: string | null
  id_not_ends_with?: string | null
  voteType?: boolean | null
  voteType_not?: boolean | null
  song?: SongWhereInput | null
  bracket?: BracketWhereInput | null
  user?: UserWhereInput | null
  AND?: VoteWhereInput[]
  OR?: VoteWhereInput[]
  NOT?: VoteWhereInput[]
}
export type VoteWhereInputInputObject =
  | Extract<keyof VoteWhereInput, string>
  | { name: 'id', alias?: string  } 
  | { name: 'id_not', alias?: string  } 
  | { name: 'id_in', alias?: string  } 
  | { name: 'id_not_in', alias?: string  } 
  | { name: 'id_lt', alias?: string  } 
  | { name: 'id_lte', alias?: string  } 
  | { name: 'id_gt', alias?: string  } 
  | { name: 'id_gte', alias?: string  } 
  | { name: 'id_contains', alias?: string  } 
  | { name: 'id_not_contains', alias?: string  } 
  | { name: 'id_starts_with', alias?: string  } 
  | { name: 'id_not_starts_with', alias?: string  } 
  | { name: 'id_ends_with', alias?: string  } 
  | { name: 'id_not_ends_with', alias?: string  } 
  | { name: 'voteType', alias?: string  } 
  | { name: 'voteType_not', alias?: string  } 
  | { name: 'song', alias?: string  } 
  | { name: 'bracket', alias?: string  } 
  | { name: 'user', alias?: string  } 
  | { name: 'AND', alias?: string  } 
  | { name: 'OR', alias?: string  } 
  | { name: 'NOT', alias?: string  } 
  
export interface SongWhereInput {
  id?: string | null
  id_not?: string | null
  id_in?: string[]
  id_not_in?: string[]
  id_lt?: string | null
  id_lte?: string | null
  id_gt?: string | null
  id_gte?: string | null
  id_contains?: string | null
  id_not_contains?: string | null
  id_starts_with?: string | null
  id_not_starts_with?: string | null
  id_ends_with?: string | null
  id_not_ends_with?: string | null
  spotifyID?: string | null
  spotifyID_not?: string | null
  spotifyID_in?: string[]
  spotifyID_not_in?: string[]
  spotifyID_lt?: string | null
  spotifyID_lte?: string | null
  spotifyID_gt?: string | null
  spotifyID_gte?: string | null
  spotifyID_contains?: string | null
  spotifyID_not_contains?: string | null
  spotifyID_starts_with?: string | null
  spotifyID_not_starts_with?: string | null
  spotifyID_ends_with?: string | null
  spotifyID_not_ends_with?: string | null
  title?: string | null
  title_not?: string | null
  title_in?: string[]
  title_not_in?: string[]
  title_lt?: string | null
  title_lte?: string | null
  title_gt?: string | null
  title_gte?: string | null
  title_contains?: string | null
  title_not_contains?: string | null
  title_starts_with?: string | null
  title_not_starts_with?: string | null
  title_ends_with?: string | null
  title_not_ends_with?: string | null
  album?: string | null
  album_not?: string | null
  album_in?: string[]
  album_not_in?: string[]
  album_lt?: string | null
  album_lte?: string | null
  album_gt?: string | null
  album_gte?: string | null
  album_contains?: string | null
  album_not_contains?: string | null
  album_starts_with?: string | null
  album_not_starts_with?: string | null
  album_ends_with?: string | null
  album_not_ends_with?: string | null
  position?: number | null
  position_not?: number | null
  position_in?: number[]
  position_not_in?: number[]
  position_lt?: number | null
  position_lte?: number | null
  position_gt?: number | null
  position_gte?: number | null
  votingStatus?: prisma.VotingStatus | null
  votingStatus_not?: prisma.VotingStatus | null
  votingStatus_in?: prisma.VotingStatus[]
  votingStatus_not_in?: prisma.VotingStatus[]
  votes_every?: VoteWhereInput | null
  votes_some?: VoteWhereInput | null
  votes_none?: VoteWhereInput | null
  AND?: SongWhereInput[]
  OR?: SongWhereInput[]
  NOT?: SongWhereInput[]
}
export type SongWhereInputInputObject =
  | Extract<keyof SongWhereInput, string>
  | { name: 'id', alias?: string  } 
  | { name: 'id_not', alias?: string  } 
  | { name: 'id_in', alias?: string  } 
  | { name: 'id_not_in', alias?: string  } 
  | { name: 'id_lt', alias?: string  } 
  | { name: 'id_lte', alias?: string  } 
  | { name: 'id_gt', alias?: string  } 
  | { name: 'id_gte', alias?: string  } 
  | { name: 'id_contains', alias?: string  } 
  | { name: 'id_not_contains', alias?: string  } 
  | { name: 'id_starts_with', alias?: string  } 
  | { name: 'id_not_starts_with', alias?: string  } 
  | { name: 'id_ends_with', alias?: string  } 
  | { name: 'id_not_ends_with', alias?: string  } 
  | { name: 'spotifyID', alias?: string  } 
  | { name: 'spotifyID_not', alias?: string  } 
  | { name: 'spotifyID_in', alias?: string  } 
  | { name: 'spotifyID_not_in', alias?: string  } 
  | { name: 'spotifyID_lt', alias?: string  } 
  | { name: 'spotifyID_lte', alias?: string  } 
  | { name: 'spotifyID_gt', alias?: string  } 
  | { name: 'spotifyID_gte', alias?: string  } 
  | { name: 'spotifyID_contains', alias?: string  } 
  | { name: 'spotifyID_not_contains', alias?: string  } 
  | { name: 'spotifyID_starts_with', alias?: string  } 
  | { name: 'spotifyID_not_starts_with', alias?: string  } 
  | { name: 'spotifyID_ends_with', alias?: string  } 
  | { name: 'spotifyID_not_ends_with', alias?: string  } 
  | { name: 'title', alias?: string  } 
  | { name: 'title_not', alias?: string  } 
  | { name: 'title_in', alias?: string  } 
  | { name: 'title_not_in', alias?: string  } 
  | { name: 'title_lt', alias?: string  } 
  | { name: 'title_lte', alias?: string  } 
  | { name: 'title_gt', alias?: string  } 
  | { name: 'title_gte', alias?: string  } 
  | { name: 'title_contains', alias?: string  } 
  | { name: 'title_not_contains', alias?: string  } 
  | { name: 'title_starts_with', alias?: string  } 
  | { name: 'title_not_starts_with', alias?: string  } 
  | { name: 'title_ends_with', alias?: string  } 
  | { name: 'title_not_ends_with', alias?: string  } 
  | { name: 'album', alias?: string  } 
  | { name: 'album_not', alias?: string  } 
  | { name: 'album_in', alias?: string  } 
  | { name: 'album_not_in', alias?: string  } 
  | { name: 'album_lt', alias?: string  } 
  | { name: 'album_lte', alias?: string  } 
  | { name: 'album_gt', alias?: string  } 
  | { name: 'album_gte', alias?: string  } 
  | { name: 'album_contains', alias?: string  } 
  | { name: 'album_not_contains', alias?: string  } 
  | { name: 'album_starts_with', alias?: string  } 
  | { name: 'album_not_starts_with', alias?: string  } 
  | { name: 'album_ends_with', alias?: string  } 
  | { name: 'album_not_ends_with', alias?: string  } 
  | { name: 'position', alias?: string  } 
  | { name: 'position_not', alias?: string  } 
  | { name: 'position_in', alias?: string  } 
  | { name: 'position_not_in', alias?: string  } 
  | { name: 'position_lt', alias?: string  } 
  | { name: 'position_lte', alias?: string  } 
  | { name: 'position_gt', alias?: string  } 
  | { name: 'position_gte', alias?: string  } 
  | { name: 'votingStatus', alias?: string  } 
  | { name: 'votingStatus_not', alias?: string  } 
  | { name: 'votingStatus_in', alias?: string  } 
  | { name: 'votingStatus_not_in', alias?: string  } 
  | { name: 'votes_every', alias?: string  } 
  | { name: 'votes_some', alias?: string  } 
  | { name: 'votes_none', alias?: string  } 
  | { name: 'AND', alias?: string  } 
  | { name: 'OR', alias?: string  } 
  | { name: 'NOT', alias?: string  } 
  
export interface BracketWhereInput {
  id?: string | null
  id_not?: string | null
  id_in?: string[]
  id_not_in?: string[]
  id_lt?: string | null
  id_lte?: string | null
  id_gt?: string | null
  id_gte?: string | null
  id_contains?: string | null
  id_not_contains?: string | null
  id_starts_with?: string | null
  id_not_starts_with?: string | null
  id_ends_with?: string | null
  id_not_ends_with?: string | null
  user?: UserWhereInput | null
  songs_every?: SongWhereInput | null
  songs_some?: SongWhereInput | null
  songs_none?: SongWhereInput | null
  roundTime?: number | null
  roundTime_not?: number | null
  roundTime_in?: number[]
  roundTime_not_in?: number[]
  roundTime_lt?: number | null
  roundTime_lte?: number | null
  roundTime_gt?: number | null
  roundTime_gte?: number | null
  active?: boolean | null
  active_not?: boolean | null
  AND?: BracketWhereInput[]
  OR?: BracketWhereInput[]
  NOT?: BracketWhereInput[]
}
export type BracketWhereInputInputObject =
  | Extract<keyof BracketWhereInput, string>
  | { name: 'id', alias?: string  } 
  | { name: 'id_not', alias?: string  } 
  | { name: 'id_in', alias?: string  } 
  | { name: 'id_not_in', alias?: string  } 
  | { name: 'id_lt', alias?: string  } 
  | { name: 'id_lte', alias?: string  } 
  | { name: 'id_gt', alias?: string  } 
  | { name: 'id_gte', alias?: string  } 
  | { name: 'id_contains', alias?: string  } 
  | { name: 'id_not_contains', alias?: string  } 
  | { name: 'id_starts_with', alias?: string  } 
  | { name: 'id_not_starts_with', alias?: string  } 
  | { name: 'id_ends_with', alias?: string  } 
  | { name: 'id_not_ends_with', alias?: string  } 
  | { name: 'user', alias?: string  } 
  | { name: 'songs_every', alias?: string  } 
  | { name: 'songs_some', alias?: string  } 
  | { name: 'songs_none', alias?: string  } 
  | { name: 'roundTime', alias?: string  } 
  | { name: 'roundTime_not', alias?: string  } 
  | { name: 'roundTime_in', alias?: string  } 
  | { name: 'roundTime_not_in', alias?: string  } 
  | { name: 'roundTime_lt', alias?: string  } 
  | { name: 'roundTime_lte', alias?: string  } 
  | { name: 'roundTime_gt', alias?: string  } 
  | { name: 'roundTime_gte', alias?: string  } 
  | { name: 'active', alias?: string  } 
  | { name: 'active_not', alias?: string  } 
  | { name: 'AND', alias?: string  } 
  | { name: 'OR', alias?: string  } 
  | { name: 'NOT', alias?: string  } 
  
export interface UserWhereInput {
  id?: string | null
  id_not?: string | null
  id_in?: string[]
  id_not_in?: string[]
  id_lt?: string | null
  id_lte?: string | null
  id_gt?: string | null
  id_gte?: string | null
  id_contains?: string | null
  id_not_contains?: string | null
  id_starts_with?: string | null
  id_not_starts_with?: string | null
  id_ends_with?: string | null
  id_not_ends_with?: string | null
  username?: string | null
  username_not?: string | null
  username_in?: string[]
  username_not_in?: string[]
  username_lt?: string | null
  username_lte?: string | null
  username_gt?: string | null
  username_gte?: string | null
  username_contains?: string | null
  username_not_contains?: string | null
  username_starts_with?: string | null
  username_not_starts_with?: string | null
  username_ends_with?: string | null
  username_not_ends_with?: string | null
  email?: string | null
  email_not?: string | null
  email_in?: string[]
  email_not_in?: string[]
  email_lt?: string | null
  email_lte?: string | null
  email_gt?: string | null
  email_gte?: string | null
  email_contains?: string | null
  email_not_contains?: string | null
  email_starts_with?: string | null
  email_not_starts_with?: string | null
  email_ends_with?: string | null
  email_not_ends_with?: string | null
  password?: string | null
  password_not?: string | null
  password_in?: string[]
  password_not_in?: string[]
  password_lt?: string | null
  password_lte?: string | null
  password_gt?: string | null
  password_gte?: string | null
  password_contains?: string | null
  password_not_contains?: string | null
  password_starts_with?: string | null
  password_not_starts_with?: string | null
  password_ends_with?: string | null
  password_not_ends_with?: string | null
  votes_every?: VoteWhereInput | null
  votes_some?: VoteWhereInput | null
  votes_none?: VoteWhereInput | null
  brackets_every?: BracketWhereInput | null
  brackets_some?: BracketWhereInput | null
  brackets_none?: BracketWhereInput | null
  AND?: UserWhereInput[]
  OR?: UserWhereInput[]
  NOT?: UserWhereInput[]
}
export type UserWhereInputInputObject =
  | Extract<keyof UserWhereInput, string>
  | { name: 'id', alias?: string  } 
  | { name: 'id_not', alias?: string  } 
  | { name: 'id_in', alias?: string  } 
  | { name: 'id_not_in', alias?: string  } 
  | { name: 'id_lt', alias?: string  } 
  | { name: 'id_lte', alias?: string  } 
  | { name: 'id_gt', alias?: string  } 
  | { name: 'id_gte', alias?: string  } 
  | { name: 'id_contains', alias?: string  } 
  | { name: 'id_not_contains', alias?: string  } 
  | { name: 'id_starts_with', alias?: string  } 
  | { name: 'id_not_starts_with', alias?: string  } 
  | { name: 'id_ends_with', alias?: string  } 
  | { name: 'id_not_ends_with', alias?: string  } 
  | { name: 'username', alias?: string  } 
  | { name: 'username_not', alias?: string  } 
  | { name: 'username_in', alias?: string  } 
  | { name: 'username_not_in', alias?: string  } 
  | { name: 'username_lt', alias?: string  } 
  | { name: 'username_lte', alias?: string  } 
  | { name: 'username_gt', alias?: string  } 
  | { name: 'username_gte', alias?: string  } 
  | { name: 'username_contains', alias?: string  } 
  | { name: 'username_not_contains', alias?: string  } 
  | { name: 'username_starts_with', alias?: string  } 
  | { name: 'username_not_starts_with', alias?: string  } 
  | { name: 'username_ends_with', alias?: string  } 
  | { name: 'username_not_ends_with', alias?: string  } 
  | { name: 'email', alias?: string  } 
  | { name: 'email_not', alias?: string  } 
  | { name: 'email_in', alias?: string  } 
  | { name: 'email_not_in', alias?: string  } 
  | { name: 'email_lt', alias?: string  } 
  | { name: 'email_lte', alias?: string  } 
  | { name: 'email_gt', alias?: string  } 
  | { name: 'email_gte', alias?: string  } 
  | { name: 'email_contains', alias?: string  } 
  | { name: 'email_not_contains', alias?: string  } 
  | { name: 'email_starts_with', alias?: string  } 
  | { name: 'email_not_starts_with', alias?: string  } 
  | { name: 'email_ends_with', alias?: string  } 
  | { name: 'email_not_ends_with', alias?: string  } 
  | { name: 'password', alias?: string  } 
  | { name: 'password_not', alias?: string  } 
  | { name: 'password_in', alias?: string  } 
  | { name: 'password_not_in', alias?: string  } 
  | { name: 'password_lt', alias?: string  } 
  | { name: 'password_lte', alias?: string  } 
  | { name: 'password_gt', alias?: string  } 
  | { name: 'password_gte', alias?: string  } 
  | { name: 'password_contains', alias?: string  } 
  | { name: 'password_not_contains', alias?: string  } 
  | { name: 'password_starts_with', alias?: string  } 
  | { name: 'password_not_starts_with', alias?: string  } 
  | { name: 'password_ends_with', alias?: string  } 
  | { name: 'password_not_ends_with', alias?: string  } 
  | { name: 'votes_every', alias?: string  } 
  | { name: 'votes_some', alias?: string  } 
  | { name: 'votes_none', alias?: string  } 
  | { name: 'brackets_every', alias?: string  } 
  | { name: 'brackets_some', alias?: string  } 
  | { name: 'brackets_none', alias?: string  } 
  | { name: 'AND', alias?: string  } 
  | { name: 'OR', alias?: string  } 
  | { name: 'NOT', alias?: string  } 
  
export interface UserWhereUniqueInput {
  id?: string | null
  username?: string | null
  email?: string | null
}
export type UserWhereUniqueInputInputObject =
  | Extract<keyof UserWhereUniqueInput, string>
  | { name: 'id', alias?: string  } 
  | { name: 'username', alias?: string  } 
  | { name: 'email', alias?: string  } 
  
export interface SongWhereUniqueInput {
  id?: string | null
}
export type SongWhereUniqueInputInputObject =
  | Extract<keyof SongWhereUniqueInput, string>
  | { name: 'id', alias?: string  } 
  
export interface BracketWhereUniqueInput {
  id?: string | null
}
export type BracketWhereUniqueInputInputObject =
  | Extract<keyof BracketWhereUniqueInput, string>
  | { name: 'id', alias?: string  } 
  
export interface VoteCreateInput {
  id?: string | null
  voteType?: boolean | null
  song?: SongCreateOneWithoutVotesInput | null
  bracket?: BracketCreateOneInput | null
  user?: UserCreateOneWithoutVotesInput
}
export type VoteCreateInputInputObject =
  | Extract<keyof VoteCreateInput, string>
  | { name: 'id', alias?: string  } 
  | { name: 'voteType', alias?: string  } 
  | { name: 'song', alias?: string  } 
  | { name: 'bracket', alias?: string  } 
  | { name: 'user', alias?: string  } 
  
export interface SongCreateOneWithoutVotesInput {
  create?: SongCreateWithoutVotesInput | null
  connect?: SongWhereUniqueInput | null
}
export type SongCreateOneWithoutVotesInputInputObject =
  | Extract<keyof SongCreateOneWithoutVotesInput, string>
  | { name: 'create', alias?: string  } 
  | { name: 'connect', alias?: string  } 
  
export interface SongCreateWithoutVotesInput {
  id?: string | null
  spotifyID?: string
  title?: string
  album?: string
  position?: number
  votingStatus?: prisma.VotingStatus
}
export type SongCreateWithoutVotesInputInputObject =
  | Extract<keyof SongCreateWithoutVotesInput, string>
  | { name: 'id', alias?: string  } 
  | { name: 'spotifyID', alias?: string  } 
  | { name: 'title', alias?: string  } 
  | { name: 'album', alias?: string  } 
  | { name: 'position', alias?: string  } 
  | { name: 'votingStatus', alias?: string  } 
  
export interface BracketCreateOneInput {
  create?: BracketCreateInput | null
  connect?: BracketWhereUniqueInput | null
}
export type BracketCreateOneInputInputObject =
  | Extract<keyof BracketCreateOneInput, string>
  | { name: 'create', alias?: string  } 
  | { name: 'connect', alias?: string  } 
  
export interface BracketCreateInput {
  id?: string | null
  user?: UserCreateOneWithoutBracketsInput
  songs?: SongCreateManyInput | null
  roundTime?: number
  active?: boolean | null
}
export type BracketCreateInputInputObject =
  | Extract<keyof BracketCreateInput, string>
  | { name: 'id', alias?: string  } 
  | { name: 'user', alias?: string  } 
  | { name: 'songs', alias?: string  } 
  | { name: 'roundTime', alias?: string  } 
  | { name: 'active', alias?: string  } 
  
export interface UserCreateOneWithoutBracketsInput {
  create?: UserCreateWithoutBracketsInput | null
  connect?: UserWhereUniqueInput | null
}
export type UserCreateOneWithoutBracketsInputInputObject =
  | Extract<keyof UserCreateOneWithoutBracketsInput, string>
  | { name: 'create', alias?: string  } 
  | { name: 'connect', alias?: string  } 
  
export interface UserCreateWithoutBracketsInput {
  id?: string | null
  username?: string
  email?: string
  password?: string
  votes?: VoteCreateManyWithoutUserInput | null
}
export type UserCreateWithoutBracketsInputInputObject =
  | Extract<keyof UserCreateWithoutBracketsInput, string>
  | { name: 'id', alias?: string  } 
  | { name: 'username', alias?: string  } 
  | { name: 'email', alias?: string  } 
  | { name: 'password', alias?: string  } 
  | { name: 'votes', alias?: string  } 
  
export interface VoteCreateManyWithoutUserInput {
  create?: VoteCreateWithoutUserInput[]
  connect?: VoteWhereUniqueInput[]
}
export type VoteCreateManyWithoutUserInputInputObject =
  | Extract<keyof VoteCreateManyWithoutUserInput, string>
  | { name: 'create', alias?: string  } 
  | { name: 'connect', alias?: string  } 
  
export interface VoteCreateWithoutUserInput {
  id?: string | null
  voteType?: boolean | null
  song?: SongCreateOneWithoutVotesInput | null
  bracket?: BracketCreateOneInput | null
}
export type VoteCreateWithoutUserInputInputObject =
  | Extract<keyof VoteCreateWithoutUserInput, string>
  | { name: 'id', alias?: string  } 
  | { name: 'voteType', alias?: string  } 
  | { name: 'song', alias?: string  } 
  | { name: 'bracket', alias?: string  } 
  
export interface SongCreateManyInput {
  create?: SongCreateInput[]
  connect?: SongWhereUniqueInput[]
}
export type SongCreateManyInputInputObject =
  | Extract<keyof SongCreateManyInput, string>
  | { name: 'create', alias?: string  } 
  | { name: 'connect', alias?: string  } 
  
export interface SongCreateInput {
  id?: string | null
  spotifyID?: string
  title?: string
  album?: string
  position?: number
  votingStatus?: prisma.VotingStatus
  votes?: VoteCreateManyWithoutSongInput | null
}
export type SongCreateInputInputObject =
  | Extract<keyof SongCreateInput, string>
  | { name: 'id', alias?: string  } 
  | { name: 'spotifyID', alias?: string  } 
  | { name: 'title', alias?: string  } 
  | { name: 'album', alias?: string  } 
  | { name: 'position', alias?: string  } 
  | { name: 'votingStatus', alias?: string  } 
  | { name: 'votes', alias?: string  } 
  
export interface VoteCreateManyWithoutSongInput {
  create?: VoteCreateWithoutSongInput[]
  connect?: VoteWhereUniqueInput[]
}
export type VoteCreateManyWithoutSongInputInputObject =
  | Extract<keyof VoteCreateManyWithoutSongInput, string>
  | { name: 'create', alias?: string  } 
  | { name: 'connect', alias?: string  } 
  
export interface VoteCreateWithoutSongInput {
  id?: string | null
  voteType?: boolean | null
  bracket?: BracketCreateOneInput | null
  user?: UserCreateOneWithoutVotesInput
}
export type VoteCreateWithoutSongInputInputObject =
  | Extract<keyof VoteCreateWithoutSongInput, string>
  | { name: 'id', alias?: string  } 
  | { name: 'voteType', alias?: string  } 
  | { name: 'bracket', alias?: string  } 
  | { name: 'user', alias?: string  } 
  
export interface UserCreateOneWithoutVotesInput {
  create?: UserCreateWithoutVotesInput | null
  connect?: UserWhereUniqueInput | null
}
export type UserCreateOneWithoutVotesInputInputObject =
  | Extract<keyof UserCreateOneWithoutVotesInput, string>
  | { name: 'create', alias?: string  } 
  | { name: 'connect', alias?: string  } 
  
export interface UserCreateWithoutVotesInput {
  id?: string | null
  username?: string
  email?: string
  password?: string
  brackets?: BracketCreateManyWithoutUserInput | null
}
export type UserCreateWithoutVotesInputInputObject =
  | Extract<keyof UserCreateWithoutVotesInput, string>
  | { name: 'id', alias?: string  } 
  | { name: 'username', alias?: string  } 
  | { name: 'email', alias?: string  } 
  | { name: 'password', alias?: string  } 
  | { name: 'brackets', alias?: string  } 
  
export interface BracketCreateManyWithoutUserInput {
  create?: BracketCreateWithoutUserInput[]
  connect?: BracketWhereUniqueInput[]
}
export type BracketCreateManyWithoutUserInputInputObject =
  | Extract<keyof BracketCreateManyWithoutUserInput, string>
  | { name: 'create', alias?: string  } 
  | { name: 'connect', alias?: string  } 
  
export interface BracketCreateWithoutUserInput {
  id?: string | null
  songs?: SongCreateManyInput | null
  roundTime?: number
  active?: boolean | null
}
export type BracketCreateWithoutUserInputInputObject =
  | Extract<keyof BracketCreateWithoutUserInput, string>
  | { name: 'id', alias?: string  } 
  | { name: 'songs', alias?: string  } 
  | { name: 'roundTime', alias?: string  } 
  | { name: 'active', alias?: string  } 
  
export interface VoteUpdateInput {
  voteType?: boolean | null
  song?: SongUpdateOneWithoutVotesInput | null
  bracket?: BracketUpdateOneInput | null
  user?: UserUpdateOneRequiredWithoutVotesInput | null
}
export type VoteUpdateInputInputObject =
  | Extract<keyof VoteUpdateInput, string>
  | { name: 'voteType', alias?: string  } 
  | { name: 'song', alias?: string  } 
  | { name: 'bracket', alias?: string  } 
  | { name: 'user', alias?: string  } 
  
export interface SongUpdateOneWithoutVotesInput {
  create?: SongCreateWithoutVotesInput | null
  update?: SongUpdateWithoutVotesDataInput | null
  upsert?: SongUpsertWithoutVotesInput | null
  delete?: boolean | null
  disconnect?: boolean | null
  connect?: SongWhereUniqueInput | null
}
export type SongUpdateOneWithoutVotesInputInputObject =
  | Extract<keyof SongUpdateOneWithoutVotesInput, string>
  | { name: 'create', alias?: string  } 
  | { name: 'update', alias?: string  } 
  | { name: 'upsert', alias?: string  } 
  | { name: 'delete', alias?: string  } 
  | { name: 'disconnect', alias?: string  } 
  | { name: 'connect', alias?: string  } 
  
export interface SongUpdateWithoutVotesDataInput {
  spotifyID?: string | null
  title?: string | null
  album?: string | null
  position?: number | null
  votingStatus?: prisma.VotingStatus | null
}
export type SongUpdateWithoutVotesDataInputInputObject =
  | Extract<keyof SongUpdateWithoutVotesDataInput, string>
  | { name: 'spotifyID', alias?: string  } 
  | { name: 'title', alias?: string  } 
  | { name: 'album', alias?: string  } 
  | { name: 'position', alias?: string  } 
  | { name: 'votingStatus', alias?: string  } 
  
export interface SongUpsertWithoutVotesInput {
  update?: SongUpdateWithoutVotesDataInput
  create?: SongCreateWithoutVotesInput
}
export type SongUpsertWithoutVotesInputInputObject =
  | Extract<keyof SongUpsertWithoutVotesInput, string>
  | { name: 'update', alias?: string  } 
  | { name: 'create', alias?: string  } 
  
export interface BracketUpdateOneInput {
  create?: BracketCreateInput | null
  update?: BracketUpdateDataInput | null
  upsert?: BracketUpsertNestedInput | null
  delete?: boolean | null
  disconnect?: boolean | null
  connect?: BracketWhereUniqueInput | null
}
export type BracketUpdateOneInputInputObject =
  | Extract<keyof BracketUpdateOneInput, string>
  | { name: 'create', alias?: string  } 
  | { name: 'update', alias?: string  } 
  | { name: 'upsert', alias?: string  } 
  | { name: 'delete', alias?: string  } 
  | { name: 'disconnect', alias?: string  } 
  | { name: 'connect', alias?: string  } 
  
export interface BracketUpdateDataInput {
  user?: UserUpdateOneRequiredWithoutBracketsInput | null
  songs?: SongUpdateManyInput | null
  roundTime?: number | null
  active?: boolean | null
}
export type BracketUpdateDataInputInputObject =
  | Extract<keyof BracketUpdateDataInput, string>
  | { name: 'user', alias?: string  } 
  | { name: 'songs', alias?: string  } 
  | { name: 'roundTime', alias?: string  } 
  | { name: 'active', alias?: string  } 
  
export interface UserUpdateOneRequiredWithoutBracketsInput {
  create?: UserCreateWithoutBracketsInput | null
  update?: UserUpdateWithoutBracketsDataInput | null
  upsert?: UserUpsertWithoutBracketsInput | null
  connect?: UserWhereUniqueInput | null
}
export type UserUpdateOneRequiredWithoutBracketsInputInputObject =
  | Extract<keyof UserUpdateOneRequiredWithoutBracketsInput, string>
  | { name: 'create', alias?: string  } 
  | { name: 'update', alias?: string  } 
  | { name: 'upsert', alias?: string  } 
  | { name: 'connect', alias?: string  } 
  
export interface UserUpdateWithoutBracketsDataInput {
  username?: string | null
  email?: string | null
  password?: string | null
  votes?: VoteUpdateManyWithoutUserInput | null
}
export type UserUpdateWithoutBracketsDataInputInputObject =
  | Extract<keyof UserUpdateWithoutBracketsDataInput, string>
  | { name: 'username', alias?: string  } 
  | { name: 'email', alias?: string  } 
  | { name: 'password', alias?: string  } 
  | { name: 'votes', alias?: string  } 
  
export interface VoteUpdateManyWithoutUserInput {
  create?: VoteCreateWithoutUserInput[]
  delete?: VoteWhereUniqueInput[]
  connect?: VoteWhereUniqueInput[]
  set?: VoteWhereUniqueInput[]
  disconnect?: VoteWhereUniqueInput[]
  update?: VoteUpdateWithWhereUniqueWithoutUserInput[]
  upsert?: VoteUpsertWithWhereUniqueWithoutUserInput[]
  deleteMany?: VoteScalarWhereInput[]
  updateMany?: VoteUpdateManyWithWhereNestedInput[]
}
export type VoteUpdateManyWithoutUserInputInputObject =
  | Extract<keyof VoteUpdateManyWithoutUserInput, string>
  | { name: 'create', alias?: string  } 
  | { name: 'delete', alias?: string  } 
  | { name: 'connect', alias?: string  } 
  | { name: 'set', alias?: string  } 
  | { name: 'disconnect', alias?: string  } 
  | { name: 'update', alias?: string  } 
  | { name: 'upsert', alias?: string  } 
  | { name: 'deleteMany', alias?: string  } 
  | { name: 'updateMany', alias?: string  } 
  
export interface VoteUpdateWithWhereUniqueWithoutUserInput {
  where?: VoteWhereUniqueInput
  data?: VoteUpdateWithoutUserDataInput
}
export type VoteUpdateWithWhereUniqueWithoutUserInputInputObject =
  | Extract<keyof VoteUpdateWithWhereUniqueWithoutUserInput, string>
  | { name: 'where', alias?: string  } 
  | { name: 'data', alias?: string  } 
  
export interface VoteUpdateWithoutUserDataInput {
  voteType?: boolean | null
  song?: SongUpdateOneWithoutVotesInput | null
  bracket?: BracketUpdateOneInput | null
}
export type VoteUpdateWithoutUserDataInputInputObject =
  | Extract<keyof VoteUpdateWithoutUserDataInput, string>
  | { name: 'voteType', alias?: string  } 
  | { name: 'song', alias?: string  } 
  | { name: 'bracket', alias?: string  } 
  
export interface VoteUpsertWithWhereUniqueWithoutUserInput {
  where?: VoteWhereUniqueInput
  update?: VoteUpdateWithoutUserDataInput
  create?: VoteCreateWithoutUserInput
}
export type VoteUpsertWithWhereUniqueWithoutUserInputInputObject =
  | Extract<keyof VoteUpsertWithWhereUniqueWithoutUserInput, string>
  | { name: 'where', alias?: string  } 
  | { name: 'update', alias?: string  } 
  | { name: 'create', alias?: string  } 
  
export interface VoteScalarWhereInput {
  id?: string | null
  id_not?: string | null
  id_in?: string[]
  id_not_in?: string[]
  id_lt?: string | null
  id_lte?: string | null
  id_gt?: string | null
  id_gte?: string | null
  id_contains?: string | null
  id_not_contains?: string | null
  id_starts_with?: string | null
  id_not_starts_with?: string | null
  id_ends_with?: string | null
  id_not_ends_with?: string | null
  voteType?: boolean | null
  voteType_not?: boolean | null
  AND?: VoteScalarWhereInput[]
  OR?: VoteScalarWhereInput[]
  NOT?: VoteScalarWhereInput[]
}
export type VoteScalarWhereInputInputObject =
  | Extract<keyof VoteScalarWhereInput, string>
  | { name: 'id', alias?: string  } 
  | { name: 'id_not', alias?: string  } 
  | { name: 'id_in', alias?: string  } 
  | { name: 'id_not_in', alias?: string  } 
  | { name: 'id_lt', alias?: string  } 
  | { name: 'id_lte', alias?: string  } 
  | { name: 'id_gt', alias?: string  } 
  | { name: 'id_gte', alias?: string  } 
  | { name: 'id_contains', alias?: string  } 
  | { name: 'id_not_contains', alias?: string  } 
  | { name: 'id_starts_with', alias?: string  } 
  | { name: 'id_not_starts_with', alias?: string  } 
  | { name: 'id_ends_with', alias?: string  } 
  | { name: 'id_not_ends_with', alias?: string  } 
  | { name: 'voteType', alias?: string  } 
  | { name: 'voteType_not', alias?: string  } 
  | { name: 'AND', alias?: string  } 
  | { name: 'OR', alias?: string  } 
  | { name: 'NOT', alias?: string  } 
  
export interface VoteUpdateManyWithWhereNestedInput {
  where?: VoteScalarWhereInput
  data?: VoteUpdateManyDataInput
}
export type VoteUpdateManyWithWhereNestedInputInputObject =
  | Extract<keyof VoteUpdateManyWithWhereNestedInput, string>
  | { name: 'where', alias?: string  } 
  | { name: 'data', alias?: string  } 
  
export interface VoteUpdateManyDataInput {
  voteType?: boolean | null
}
export type VoteUpdateManyDataInputInputObject =
  | Extract<keyof VoteUpdateManyDataInput, string>
  | { name: 'voteType', alias?: string  } 
  
export interface UserUpsertWithoutBracketsInput {
  update?: UserUpdateWithoutBracketsDataInput
  create?: UserCreateWithoutBracketsInput
}
export type UserUpsertWithoutBracketsInputInputObject =
  | Extract<keyof UserUpsertWithoutBracketsInput, string>
  | { name: 'update', alias?: string  } 
  | { name: 'create', alias?: string  } 
  
export interface SongUpdateManyInput {
  create?: SongCreateInput[]
  update?: SongUpdateWithWhereUniqueNestedInput[]
  upsert?: SongUpsertWithWhereUniqueNestedInput[]
  delete?: SongWhereUniqueInput[]
  connect?: SongWhereUniqueInput[]
  set?: SongWhereUniqueInput[]
  disconnect?: SongWhereUniqueInput[]
  deleteMany?: SongScalarWhereInput[]
  updateMany?: SongUpdateManyWithWhereNestedInput[]
}
export type SongUpdateManyInputInputObject =
  | Extract<keyof SongUpdateManyInput, string>
  | { name: 'create', alias?: string  } 
  | { name: 'update', alias?: string  } 
  | { name: 'upsert', alias?: string  } 
  | { name: 'delete', alias?: string  } 
  | { name: 'connect', alias?: string  } 
  | { name: 'set', alias?: string  } 
  | { name: 'disconnect', alias?: string  } 
  | { name: 'deleteMany', alias?: string  } 
  | { name: 'updateMany', alias?: string  } 
  
export interface SongUpdateWithWhereUniqueNestedInput {
  where?: SongWhereUniqueInput
  data?: SongUpdateDataInput
}
export type SongUpdateWithWhereUniqueNestedInputInputObject =
  | Extract<keyof SongUpdateWithWhereUniqueNestedInput, string>
  | { name: 'where', alias?: string  } 
  | { name: 'data', alias?: string  } 
  
export interface SongUpdateDataInput {
  spotifyID?: string | null
  title?: string | null
  album?: string | null
  position?: number | null
  votingStatus?: prisma.VotingStatus | null
  votes?: VoteUpdateManyWithoutSongInput | null
}
export type SongUpdateDataInputInputObject =
  | Extract<keyof SongUpdateDataInput, string>
  | { name: 'spotifyID', alias?: string  } 
  | { name: 'title', alias?: string  } 
  | { name: 'album', alias?: string  } 
  | { name: 'position', alias?: string  } 
  | { name: 'votingStatus', alias?: string  } 
  | { name: 'votes', alias?: string  } 
  
export interface VoteUpdateManyWithoutSongInput {
  create?: VoteCreateWithoutSongInput[]
  delete?: VoteWhereUniqueInput[]
  connect?: VoteWhereUniqueInput[]
  set?: VoteWhereUniqueInput[]
  disconnect?: VoteWhereUniqueInput[]
  update?: VoteUpdateWithWhereUniqueWithoutSongInput[]
  upsert?: VoteUpsertWithWhereUniqueWithoutSongInput[]
  deleteMany?: VoteScalarWhereInput[]
  updateMany?: VoteUpdateManyWithWhereNestedInput[]
}
export type VoteUpdateManyWithoutSongInputInputObject =
  | Extract<keyof VoteUpdateManyWithoutSongInput, string>
  | { name: 'create', alias?: string  } 
  | { name: 'delete', alias?: string  } 
  | { name: 'connect', alias?: string  } 
  | { name: 'set', alias?: string  } 
  | { name: 'disconnect', alias?: string  } 
  | { name: 'update', alias?: string  } 
  | { name: 'upsert', alias?: string  } 
  | { name: 'deleteMany', alias?: string  } 
  | { name: 'updateMany', alias?: string  } 
  
export interface VoteUpdateWithWhereUniqueWithoutSongInput {
  where?: VoteWhereUniqueInput
  data?: VoteUpdateWithoutSongDataInput
}
export type VoteUpdateWithWhereUniqueWithoutSongInputInputObject =
  | Extract<keyof VoteUpdateWithWhereUniqueWithoutSongInput, string>
  | { name: 'where', alias?: string  } 
  | { name: 'data', alias?: string  } 
  
export interface VoteUpdateWithoutSongDataInput {
  voteType?: boolean | null
  bracket?: BracketUpdateOneInput | null
  user?: UserUpdateOneRequiredWithoutVotesInput | null
}
export type VoteUpdateWithoutSongDataInputInputObject =
  | Extract<keyof VoteUpdateWithoutSongDataInput, string>
  | { name: 'voteType', alias?: string  } 
  | { name: 'bracket', alias?: string  } 
  | { name: 'user', alias?: string  } 
  
export interface UserUpdateOneRequiredWithoutVotesInput {
  create?: UserCreateWithoutVotesInput | null
  update?: UserUpdateWithoutVotesDataInput | null
  upsert?: UserUpsertWithoutVotesInput | null
  connect?: UserWhereUniqueInput | null
}
export type UserUpdateOneRequiredWithoutVotesInputInputObject =
  | Extract<keyof UserUpdateOneRequiredWithoutVotesInput, string>
  | { name: 'create', alias?: string  } 
  | { name: 'update', alias?: string  } 
  | { name: 'upsert', alias?: string  } 
  | { name: 'connect', alias?: string  } 
  
export interface UserUpdateWithoutVotesDataInput {
  username?: string | null
  email?: string | null
  password?: string | null
  brackets?: BracketUpdateManyWithoutUserInput | null
}
export type UserUpdateWithoutVotesDataInputInputObject =
  | Extract<keyof UserUpdateWithoutVotesDataInput, string>
  | { name: 'username', alias?: string  } 
  | { name: 'email', alias?: string  } 
  | { name: 'password', alias?: string  } 
  | { name: 'brackets', alias?: string  } 
  
export interface BracketUpdateManyWithoutUserInput {
  create?: BracketCreateWithoutUserInput[]
  delete?: BracketWhereUniqueInput[]
  connect?: BracketWhereUniqueInput[]
  set?: BracketWhereUniqueInput[]
  disconnect?: BracketWhereUniqueInput[]
  update?: BracketUpdateWithWhereUniqueWithoutUserInput[]
  upsert?: BracketUpsertWithWhereUniqueWithoutUserInput[]
  deleteMany?: BracketScalarWhereInput[]
  updateMany?: BracketUpdateManyWithWhereNestedInput[]
}
export type BracketUpdateManyWithoutUserInputInputObject =
  | Extract<keyof BracketUpdateManyWithoutUserInput, string>
  | { name: 'create', alias?: string  } 
  | { name: 'delete', alias?: string  } 
  | { name: 'connect', alias?: string  } 
  | { name: 'set', alias?: string  } 
  | { name: 'disconnect', alias?: string  } 
  | { name: 'update', alias?: string  } 
  | { name: 'upsert', alias?: string  } 
  | { name: 'deleteMany', alias?: string  } 
  | { name: 'updateMany', alias?: string  } 
  
export interface BracketUpdateWithWhereUniqueWithoutUserInput {
  where?: BracketWhereUniqueInput
  data?: BracketUpdateWithoutUserDataInput
}
export type BracketUpdateWithWhereUniqueWithoutUserInputInputObject =
  | Extract<keyof BracketUpdateWithWhereUniqueWithoutUserInput, string>
  | { name: 'where', alias?: string  } 
  | { name: 'data', alias?: string  } 
  
export interface BracketUpdateWithoutUserDataInput {
  songs?: SongUpdateManyInput | null
  roundTime?: number | null
  active?: boolean | null
}
export type BracketUpdateWithoutUserDataInputInputObject =
  | Extract<keyof BracketUpdateWithoutUserDataInput, string>
  | { name: 'songs', alias?: string  } 
  | { name: 'roundTime', alias?: string  } 
  | { name: 'active', alias?: string  } 
  
export interface BracketUpsertWithWhereUniqueWithoutUserInput {
  where?: BracketWhereUniqueInput
  update?: BracketUpdateWithoutUserDataInput
  create?: BracketCreateWithoutUserInput
}
export type BracketUpsertWithWhereUniqueWithoutUserInputInputObject =
  | Extract<keyof BracketUpsertWithWhereUniqueWithoutUserInput, string>
  | { name: 'where', alias?: string  } 
  | { name: 'update', alias?: string  } 
  | { name: 'create', alias?: string  } 
  
export interface BracketScalarWhereInput {
  id?: string | null
  id_not?: string | null
  id_in?: string[]
  id_not_in?: string[]
  id_lt?: string | null
  id_lte?: string | null
  id_gt?: string | null
  id_gte?: string | null
  id_contains?: string | null
  id_not_contains?: string | null
  id_starts_with?: string | null
  id_not_starts_with?: string | null
  id_ends_with?: string | null
  id_not_ends_with?: string | null
  roundTime?: number | null
  roundTime_not?: number | null
  roundTime_in?: number[]
  roundTime_not_in?: number[]
  roundTime_lt?: number | null
  roundTime_lte?: number | null
  roundTime_gt?: number | null
  roundTime_gte?: number | null
  active?: boolean | null
  active_not?: boolean | null
  AND?: BracketScalarWhereInput[]
  OR?: BracketScalarWhereInput[]
  NOT?: BracketScalarWhereInput[]
}
export type BracketScalarWhereInputInputObject =
  | Extract<keyof BracketScalarWhereInput, string>
  | { name: 'id', alias?: string  } 
  | { name: 'id_not', alias?: string  } 
  | { name: 'id_in', alias?: string  } 
  | { name: 'id_not_in', alias?: string  } 
  | { name: 'id_lt', alias?: string  } 
  | { name: 'id_lte', alias?: string  } 
  | { name: 'id_gt', alias?: string  } 
  | { name: 'id_gte', alias?: string  } 
  | { name: 'id_contains', alias?: string  } 
  | { name: 'id_not_contains', alias?: string  } 
  | { name: 'id_starts_with', alias?: string  } 
  | { name: 'id_not_starts_with', alias?: string  } 
  | { name: 'id_ends_with', alias?: string  } 
  | { name: 'id_not_ends_with', alias?: string  } 
  | { name: 'roundTime', alias?: string  } 
  | { name: 'roundTime_not', alias?: string  } 
  | { name: 'roundTime_in', alias?: string  } 
  | { name: 'roundTime_not_in', alias?: string  } 
  | { name: 'roundTime_lt', alias?: string  } 
  | { name: 'roundTime_lte', alias?: string  } 
  | { name: 'roundTime_gt', alias?: string  } 
  | { name: 'roundTime_gte', alias?: string  } 
  | { name: 'active', alias?: string  } 
  | { name: 'active_not', alias?: string  } 
  | { name: 'AND', alias?: string  } 
  | { name: 'OR', alias?: string  } 
  | { name: 'NOT', alias?: string  } 
  
export interface BracketUpdateManyWithWhereNestedInput {
  where?: BracketScalarWhereInput
  data?: BracketUpdateManyDataInput
}
export type BracketUpdateManyWithWhereNestedInputInputObject =
  | Extract<keyof BracketUpdateManyWithWhereNestedInput, string>
  | { name: 'where', alias?: string  } 
  | { name: 'data', alias?: string  } 
  
export interface BracketUpdateManyDataInput {
  roundTime?: number | null
  active?: boolean | null
}
export type BracketUpdateManyDataInputInputObject =
  | Extract<keyof BracketUpdateManyDataInput, string>
  | { name: 'roundTime', alias?: string  } 
  | { name: 'active', alias?: string  } 
  
export interface UserUpsertWithoutVotesInput {
  update?: UserUpdateWithoutVotesDataInput
  create?: UserCreateWithoutVotesInput
}
export type UserUpsertWithoutVotesInputInputObject =
  | Extract<keyof UserUpsertWithoutVotesInput, string>
  | { name: 'update', alias?: string  } 
  | { name: 'create', alias?: string  } 
  
export interface VoteUpsertWithWhereUniqueWithoutSongInput {
  where?: VoteWhereUniqueInput
  update?: VoteUpdateWithoutSongDataInput
  create?: VoteCreateWithoutSongInput
}
export type VoteUpsertWithWhereUniqueWithoutSongInputInputObject =
  | Extract<keyof VoteUpsertWithWhereUniqueWithoutSongInput, string>
  | { name: 'where', alias?: string  } 
  | { name: 'update', alias?: string  } 
  | { name: 'create', alias?: string  } 
  
export interface SongUpsertWithWhereUniqueNestedInput {
  where?: SongWhereUniqueInput
  update?: SongUpdateDataInput
  create?: SongCreateInput
}
export type SongUpsertWithWhereUniqueNestedInputInputObject =
  | Extract<keyof SongUpsertWithWhereUniqueNestedInput, string>
  | { name: 'where', alias?: string  } 
  | { name: 'update', alias?: string  } 
  | { name: 'create', alias?: string  } 
  
export interface SongScalarWhereInput {
  id?: string | null
  id_not?: string | null
  id_in?: string[]
  id_not_in?: string[]
  id_lt?: string | null
  id_lte?: string | null
  id_gt?: string | null
  id_gte?: string | null
  id_contains?: string | null
  id_not_contains?: string | null
  id_starts_with?: string | null
  id_not_starts_with?: string | null
  id_ends_with?: string | null
  id_not_ends_with?: string | null
  spotifyID?: string | null
  spotifyID_not?: string | null
  spotifyID_in?: string[]
  spotifyID_not_in?: string[]
  spotifyID_lt?: string | null
  spotifyID_lte?: string | null
  spotifyID_gt?: string | null
  spotifyID_gte?: string | null
  spotifyID_contains?: string | null
  spotifyID_not_contains?: string | null
  spotifyID_starts_with?: string | null
  spotifyID_not_starts_with?: string | null
  spotifyID_ends_with?: string | null
  spotifyID_not_ends_with?: string | null
  title?: string | null
  title_not?: string | null
  title_in?: string[]
  title_not_in?: string[]
  title_lt?: string | null
  title_lte?: string | null
  title_gt?: string | null
  title_gte?: string | null
  title_contains?: string | null
  title_not_contains?: string | null
  title_starts_with?: string | null
  title_not_starts_with?: string | null
  title_ends_with?: string | null
  title_not_ends_with?: string | null
  album?: string | null
  album_not?: string | null
  album_in?: string[]
  album_not_in?: string[]
  album_lt?: string | null
  album_lte?: string | null
  album_gt?: string | null
  album_gte?: string | null
  album_contains?: string | null
  album_not_contains?: string | null
  album_starts_with?: string | null
  album_not_starts_with?: string | null
  album_ends_with?: string | null
  album_not_ends_with?: string | null
  position?: number | null
  position_not?: number | null
  position_in?: number[]
  position_not_in?: number[]
  position_lt?: number | null
  position_lte?: number | null
  position_gt?: number | null
  position_gte?: number | null
  votingStatus?: prisma.VotingStatus | null
  votingStatus_not?: prisma.VotingStatus | null
  votingStatus_in?: prisma.VotingStatus[]
  votingStatus_not_in?: prisma.VotingStatus[]
  AND?: SongScalarWhereInput[]
  OR?: SongScalarWhereInput[]
  NOT?: SongScalarWhereInput[]
}
export type SongScalarWhereInputInputObject =
  | Extract<keyof SongScalarWhereInput, string>
  | { name: 'id', alias?: string  } 
  | { name: 'id_not', alias?: string  } 
  | { name: 'id_in', alias?: string  } 
  | { name: 'id_not_in', alias?: string  } 
  | { name: 'id_lt', alias?: string  } 
  | { name: 'id_lte', alias?: string  } 
  | { name: 'id_gt', alias?: string  } 
  | { name: 'id_gte', alias?: string  } 
  | { name: 'id_contains', alias?: string  } 
  | { name: 'id_not_contains', alias?: string  } 
  | { name: 'id_starts_with', alias?: string  } 
  | { name: 'id_not_starts_with', alias?: string  } 
  | { name: 'id_ends_with', alias?: string  } 
  | { name: 'id_not_ends_with', alias?: string  } 
  | { name: 'spotifyID', alias?: string  } 
  | { name: 'spotifyID_not', alias?: string  } 
  | { name: 'spotifyID_in', alias?: string  } 
  | { name: 'spotifyID_not_in', alias?: string  } 
  | { name: 'spotifyID_lt', alias?: string  } 
  | { name: 'spotifyID_lte', alias?: string  } 
  | { name: 'spotifyID_gt', alias?: string  } 
  | { name: 'spotifyID_gte', alias?: string  } 
  | { name: 'spotifyID_contains', alias?: string  } 
  | { name: 'spotifyID_not_contains', alias?: string  } 
  | { name: 'spotifyID_starts_with', alias?: string  } 
  | { name: 'spotifyID_not_starts_with', alias?: string  } 
  | { name: 'spotifyID_ends_with', alias?: string  } 
  | { name: 'spotifyID_not_ends_with', alias?: string  } 
  | { name: 'title', alias?: string  } 
  | { name: 'title_not', alias?: string  } 
  | { name: 'title_in', alias?: string  } 
  | { name: 'title_not_in', alias?: string  } 
  | { name: 'title_lt', alias?: string  } 
  | { name: 'title_lte', alias?: string  } 
  | { name: 'title_gt', alias?: string  } 
  | { name: 'title_gte', alias?: string  } 
  | { name: 'title_contains', alias?: string  } 
  | { name: 'title_not_contains', alias?: string  } 
  | { name: 'title_starts_with', alias?: string  } 
  | { name: 'title_not_starts_with', alias?: string  } 
  | { name: 'title_ends_with', alias?: string  } 
  | { name: 'title_not_ends_with', alias?: string  } 
  | { name: 'album', alias?: string  } 
  | { name: 'album_not', alias?: string  } 
  | { name: 'album_in', alias?: string  } 
  | { name: 'album_not_in', alias?: string  } 
  | { name: 'album_lt', alias?: string  } 
  | { name: 'album_lte', alias?: string  } 
  | { name: 'album_gt', alias?: string  } 
  | { name: 'album_gte', alias?: string  } 
  | { name: 'album_contains', alias?: string  } 
  | { name: 'album_not_contains', alias?: string  } 
  | { name: 'album_starts_with', alias?: string  } 
  | { name: 'album_not_starts_with', alias?: string  } 
  | { name: 'album_ends_with', alias?: string  } 
  | { name: 'album_not_ends_with', alias?: string  } 
  | { name: 'position', alias?: string  } 
  | { name: 'position_not', alias?: string  } 
  | { name: 'position_in', alias?: string  } 
  | { name: 'position_not_in', alias?: string  } 
  | { name: 'position_lt', alias?: string  } 
  | { name: 'position_lte', alias?: string  } 
  | { name: 'position_gt', alias?: string  } 
  | { name: 'position_gte', alias?: string  } 
  | { name: 'votingStatus', alias?: string  } 
  | { name: 'votingStatus_not', alias?: string  } 
  | { name: 'votingStatus_in', alias?: string  } 
  | { name: 'votingStatus_not_in', alias?: string  } 
  | { name: 'AND', alias?: string  } 
  | { name: 'OR', alias?: string  } 
  | { name: 'NOT', alias?: string  } 
  
export interface SongUpdateManyWithWhereNestedInput {
  where?: SongScalarWhereInput
  data?: SongUpdateManyDataInput
}
export type SongUpdateManyWithWhereNestedInputInputObject =
  | Extract<keyof SongUpdateManyWithWhereNestedInput, string>
  | { name: 'where', alias?: string  } 
  | { name: 'data', alias?: string  } 
  
export interface SongUpdateManyDataInput {
  spotifyID?: string | null
  title?: string | null
  album?: string | null
  position?: number | null
  votingStatus?: prisma.VotingStatus | null
}
export type SongUpdateManyDataInputInputObject =
  | Extract<keyof SongUpdateManyDataInput, string>
  | { name: 'spotifyID', alias?: string  } 
  | { name: 'title', alias?: string  } 
  | { name: 'album', alias?: string  } 
  | { name: 'position', alias?: string  } 
  | { name: 'votingStatus', alias?: string  } 
  
export interface BracketUpsertNestedInput {
  update?: BracketUpdateDataInput
  create?: BracketCreateInput
}
export type BracketUpsertNestedInputInputObject =
  | Extract<keyof BracketUpsertNestedInput, string>
  | { name: 'update', alias?: string  } 
  | { name: 'create', alias?: string  } 
  
export interface VoteUpdateManyMutationInput {
  voteType?: boolean | null
}
export type VoteUpdateManyMutationInputInputObject =
  | Extract<keyof VoteUpdateManyMutationInput, string>
  | { name: 'voteType', alias?: string  } 
  
export interface UserCreateInput {
  id?: string | null
  username?: string
  email?: string
  password?: string
  votes?: VoteCreateManyWithoutUserInput | null
  brackets?: BracketCreateManyWithoutUserInput | null
}
export type UserCreateInputInputObject =
  | Extract<keyof UserCreateInput, string>
  | { name: 'id', alias?: string  } 
  | { name: 'username', alias?: string  } 
  | { name: 'email', alias?: string  } 
  | { name: 'password', alias?: string  } 
  | { name: 'votes', alias?: string  } 
  | { name: 'brackets', alias?: string  } 
  
export interface UserUpdateInput {
  username?: string | null
  email?: string | null
  password?: string | null
  votes?: VoteUpdateManyWithoutUserInput | null
  brackets?: BracketUpdateManyWithoutUserInput | null
}
export type UserUpdateInputInputObject =
  | Extract<keyof UserUpdateInput, string>
  | { name: 'username', alias?: string  } 
  | { name: 'email', alias?: string  } 
  | { name: 'password', alias?: string  } 
  | { name: 'votes', alias?: string  } 
  | { name: 'brackets', alias?: string  } 
  
export interface UserUpdateManyMutationInput {
  username?: string | null
  email?: string | null
  password?: string | null
}
export type UserUpdateManyMutationInputInputObject =
  | Extract<keyof UserUpdateManyMutationInput, string>
  | { name: 'username', alias?: string  } 
  | { name: 'email', alias?: string  } 
  | { name: 'password', alias?: string  } 
  
export interface SongUpdateInput {
  spotifyID?: string | null
  title?: string | null
  album?: string | null
  position?: number | null
  votingStatus?: prisma.VotingStatus | null
  votes?: VoteUpdateManyWithoutSongInput | null
}
export type SongUpdateInputInputObject =
  | Extract<keyof SongUpdateInput, string>
  | { name: 'spotifyID', alias?: string  } 
  | { name: 'title', alias?: string  } 
  | { name: 'album', alias?: string  } 
  | { name: 'position', alias?: string  } 
  | { name: 'votingStatus', alias?: string  } 
  | { name: 'votes', alias?: string  } 
  
export interface SongUpdateManyMutationInput {
  spotifyID?: string | null
  title?: string | null
  album?: string | null
  position?: number | null
  votingStatus?: prisma.VotingStatus | null
}
export type SongUpdateManyMutationInputInputObject =
  | Extract<keyof SongUpdateManyMutationInput, string>
  | { name: 'spotifyID', alias?: string  } 
  | { name: 'title', alias?: string  } 
  | { name: 'album', alias?: string  } 
  | { name: 'position', alias?: string  } 
  | { name: 'votingStatus', alias?: string  } 
  
export interface BracketUpdateInput {
  user?: UserUpdateOneRequiredWithoutBracketsInput | null
  songs?: SongUpdateManyInput | null
  roundTime?: number | null
  active?: boolean | null
}
export type BracketUpdateInputInputObject =
  | Extract<keyof BracketUpdateInput, string>
  | { name: 'user', alias?: string  } 
  | { name: 'songs', alias?: string  } 
  | { name: 'roundTime', alias?: string  } 
  | { name: 'active', alias?: string  } 
  
export interface BracketUpdateManyMutationInput {
  roundTime?: number | null
  active?: boolean | null
}
export type BracketUpdateManyMutationInputInputObject =
  | Extract<keyof BracketUpdateManyMutationInput, string>
  | { name: 'roundTime', alias?: string  } 
  | { name: 'active', alias?: string  } 
  
export interface VoteSubscriptionWhereInput {
  mutation_in?: prisma.MutationType[]
  updatedFields_contains?: string | null
  updatedFields_contains_every?: string[]
  updatedFields_contains_some?: string[]
  node?: VoteWhereInput | null
  AND?: VoteSubscriptionWhereInput[]
  OR?: VoteSubscriptionWhereInput[]
  NOT?: VoteSubscriptionWhereInput[]
}
export type VoteSubscriptionWhereInputInputObject =
  | Extract<keyof VoteSubscriptionWhereInput, string>
  | { name: 'mutation_in', alias?: string  } 
  | { name: 'updatedFields_contains', alias?: string  } 
  | { name: 'updatedFields_contains_every', alias?: string  } 
  | { name: 'updatedFields_contains_some', alias?: string  } 
  | { name: 'node', alias?: string  } 
  | { name: 'AND', alias?: string  } 
  | { name: 'OR', alias?: string  } 
  | { name: 'NOT', alias?: string  } 
  
export interface UserSubscriptionWhereInput {
  mutation_in?: prisma.MutationType[]
  updatedFields_contains?: string | null
  updatedFields_contains_every?: string[]
  updatedFields_contains_some?: string[]
  node?: UserWhereInput | null
  AND?: UserSubscriptionWhereInput[]
  OR?: UserSubscriptionWhereInput[]
  NOT?: UserSubscriptionWhereInput[]
}
export type UserSubscriptionWhereInputInputObject =
  | Extract<keyof UserSubscriptionWhereInput, string>
  | { name: 'mutation_in', alias?: string  } 
  | { name: 'updatedFields_contains', alias?: string  } 
  | { name: 'updatedFields_contains_every', alias?: string  } 
  | { name: 'updatedFields_contains_some', alias?: string  } 
  | { name: 'node', alias?: string  } 
  | { name: 'AND', alias?: string  } 
  | { name: 'OR', alias?: string  } 
  | { name: 'NOT', alias?: string  } 
  
export interface SongSubscriptionWhereInput {
  mutation_in?: prisma.MutationType[]
  updatedFields_contains?: string | null
  updatedFields_contains_every?: string[]
  updatedFields_contains_some?: string[]
  node?: SongWhereInput | null
  AND?: SongSubscriptionWhereInput[]
  OR?: SongSubscriptionWhereInput[]
  NOT?: SongSubscriptionWhereInput[]
}
export type SongSubscriptionWhereInputInputObject =
  | Extract<keyof SongSubscriptionWhereInput, string>
  | { name: 'mutation_in', alias?: string  } 
  | { name: 'updatedFields_contains', alias?: string  } 
  | { name: 'updatedFields_contains_every', alias?: string  } 
  | { name: 'updatedFields_contains_some', alias?: string  } 
  | { name: 'node', alias?: string  } 
  | { name: 'AND', alias?: string  } 
  | { name: 'OR', alias?: string  } 
  | { name: 'NOT', alias?: string  } 
  
export interface BracketSubscriptionWhereInput {
  mutation_in?: prisma.MutationType[]
  updatedFields_contains?: string | null
  updatedFields_contains_every?: string[]
  updatedFields_contains_some?: string[]
  node?: BracketWhereInput | null
  AND?: BracketSubscriptionWhereInput[]
  OR?: BracketSubscriptionWhereInput[]
  NOT?: BracketSubscriptionWhereInput[]
}
export type BracketSubscriptionWhereInputInputObject =
  | Extract<keyof BracketSubscriptionWhereInput, string>
  | { name: 'mutation_in', alias?: string  } 
  | { name: 'updatedFields_contains', alias?: string  } 
  | { name: 'updatedFields_contains_every', alias?: string  } 
  | { name: 'updatedFields_contains_some', alias?: string  } 
  | { name: 'node', alias?: string  } 
  | { name: 'AND', alias?: string  } 
  | { name: 'OR', alias?: string  } 
  | { name: 'NOT', alias?: string  } 
  

export type VotingStatusValues =
  | 'WIN'
  | 'LOSS'
  | 'IN_PROGRESS'
  
export type VoteOrderByInputValues =
  | 'id_ASC'
  | 'id_DESC'
  | 'voteType_ASC'
  | 'voteType_DESC'
  | 'createdAt_ASC'
  | 'createdAt_DESC'
  | 'updatedAt_ASC'
  | 'updatedAt_DESC'
  
export type BracketOrderByInputValues =
  | 'id_ASC'
  | 'id_DESC'
  | 'roundTime_ASC'
  | 'roundTime_DESC'
  | 'active_ASC'
  | 'active_DESC'
  | 'createdAt_ASC'
  | 'createdAt_DESC'
  | 'updatedAt_ASC'
  | 'updatedAt_DESC'
  
export type SongOrderByInputValues =
  | 'id_ASC'
  | 'id_DESC'
  | 'spotifyID_ASC'
  | 'spotifyID_DESC'
  | 'title_ASC'
  | 'title_DESC'
  | 'album_ASC'
  | 'album_DESC'
  | 'position_ASC'
  | 'position_DESC'
  | 'votingStatus_ASC'
  | 'votingStatus_DESC'
  | 'createdAt_ASC'
  | 'createdAt_DESC'
  | 'updatedAt_ASC'
  | 'updatedAt_DESC'
  
export type UserOrderByInputValues =
  | 'id_ASC'
  | 'id_DESC'
  | 'username_ASC'
  | 'username_DESC'
  | 'email_ASC'
  | 'email_DESC'
  | 'password_ASC'
  | 'password_DESC'
  | 'createdAt_ASC'
  | 'createdAt_DESC'
  | 'updatedAt_ASC'
  | 'updatedAt_DESC'
  
export type MutationTypeValues =
  | 'CREATED'
  | 'UPDATED'
  | 'DELETED'
  
  