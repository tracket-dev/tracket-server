### This file was autogenerated by GraphQL Nexus
### Do not make changes to this file directly


type BatchPayload {
  count: Long!
}

type Bracket {
  active: Boolean
  id: ID!
  roundTime: Int!
  songs(after: String, before: String, first: Int, last: Int, orderBy: SongOrderByInput, skip: Int, where: SongWhereInput): [Song!]
  user: User!
}

input BracketCreateInput {
  active: Boolean
  id: ID
  roundTime: Int!
  songs: SongCreateManyInput
  user: UserCreateOneWithoutBracketsInput!
}

input BracketCreateManyWithoutUserInput {
  connect: [BracketWhereUniqueInput!]
  create: [BracketCreateWithoutUserInput!]
}

input BracketCreateOneInput {
  connect: BracketWhereUniqueInput
  create: BracketCreateInput
}

input BracketCreateWithoutUserInput {
  active: Boolean
  id: ID
  roundTime: Int!
  songs: SongCreateManyInput
}

enum BracketOrderByInput {
  active_ASC
  active_DESC
  createdAt_ASC
  createdAt_DESC
  id_ASC
  id_DESC
  roundTime_ASC
  roundTime_DESC
  updatedAt_ASC
  updatedAt_DESC
}

input BracketScalarWhereInput {
  active: Boolean
  active_not: Boolean
  AND: [BracketScalarWhereInput!]
  id: ID
  id_contains: ID
  id_ends_with: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_contains: ID
  id_not_ends_with: ID
  id_not_in: [ID!]
  id_not_starts_with: ID
  id_starts_with: ID
  NOT: [BracketScalarWhereInput!]
  OR: [BracketScalarWhereInput!]
  roundTime: Int
  roundTime_gt: Int
  roundTime_gte: Int
  roundTime_in: [Int!]
  roundTime_lt: Int
  roundTime_lte: Int
  roundTime_not: Int
  roundTime_not_in: [Int!]
}

input BracketUpdateDataInput {
  active: Boolean
  roundTime: Int
  songs: SongUpdateManyInput
  user: UserUpdateOneRequiredWithoutBracketsInput
}

input BracketUpdateInput {
  active: Boolean
  roundTime: Int
  songs: SongUpdateManyInput
  user: UserUpdateOneRequiredWithoutBracketsInput
}

input BracketUpdateManyDataInput {
  active: Boolean
  roundTime: Int
}

input BracketUpdateManyMutationInput {
  active: Boolean
  roundTime: Int
}

input BracketUpdateManyWithoutUserInput {
  connect: [BracketWhereUniqueInput!]
  create: [BracketCreateWithoutUserInput!]
  delete: [BracketWhereUniqueInput!]
  deleteMany: [BracketScalarWhereInput!]
  disconnect: [BracketWhereUniqueInput!]
  set: [BracketWhereUniqueInput!]
  update: [BracketUpdateWithWhereUniqueWithoutUserInput!]
  updateMany: [BracketUpdateManyWithWhereNestedInput!]
  upsert: [BracketUpsertWithWhereUniqueWithoutUserInput!]
}

input BracketUpdateManyWithWhereNestedInput {
  data: BracketUpdateManyDataInput!
  where: BracketScalarWhereInput!
}

input BracketUpdateOneInput {
  connect: BracketWhereUniqueInput
  create: BracketCreateInput
  delete: Boolean
  disconnect: Boolean
  update: BracketUpdateDataInput
  upsert: BracketUpsertNestedInput
}

input BracketUpdateWithoutUserDataInput {
  active: Boolean
  roundTime: Int
  songs: SongUpdateManyInput
}

input BracketUpdateWithWhereUniqueWithoutUserInput {
  data: BracketUpdateWithoutUserDataInput!
  where: BracketWhereUniqueInput!
}

input BracketUpsertNestedInput {
  create: BracketCreateInput!
  update: BracketUpdateDataInput!
}

input BracketUpsertWithWhereUniqueWithoutUserInput {
  create: BracketCreateWithoutUserInput!
  update: BracketUpdateWithoutUserDataInput!
  where: BracketWhereUniqueInput!
}

input BracketWhereInput {
  active: Boolean
  active_not: Boolean
  AND: [BracketWhereInput!]
  id: ID
  id_contains: ID
  id_ends_with: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_contains: ID
  id_not_ends_with: ID
  id_not_in: [ID!]
  id_not_starts_with: ID
  id_starts_with: ID
  NOT: [BracketWhereInput!]
  OR: [BracketWhereInput!]
  roundTime: Int
  roundTime_gt: Int
  roundTime_gte: Int
  roundTime_in: [Int!]
  roundTime_lt: Int
  roundTime_lte: Int
  roundTime_not: Int
  roundTime_not_in: [Int!]
  songs_every: SongWhereInput
  songs_none: SongWhereInput
  songs_some: SongWhereInput
  user: UserWhereInput
}

input BracketWhereUniqueInput {
  id: ID
}

scalar Long

type Mutation {
  createBracket(data: BracketCreateInput!): Bracket!
  createSong(data: SongCreateInput!): Song!
  createUser(data: UserCreateInput!): User!
  createVote(data: VoteCreateInput!): Vote!
  deleteBracket(where: BracketWhereUniqueInput!): Bracket
  deleteManyBrackets(where: BracketWhereInput): BatchPayload!
  deleteManySongs(where: SongWhereInput): BatchPayload!
  deleteManyUsers(where: UserWhereInput): BatchPayload!
  deleteManyVotes(where: VoteWhereInput): BatchPayload!
  deleteSong(where: SongWhereUniqueInput!): Song
  deleteUser(where: UserWhereUniqueInput!): User
  deleteVote(where: VoteWhereUniqueInput!): Vote
  updateBracket(data: BracketUpdateInput!, where: BracketWhereUniqueInput!): Bracket
  updateManyBrackets(data: BracketUpdateManyMutationInput!, where: BracketWhereInput): BatchPayload!
  updateManySongs(data: SongUpdateManyMutationInput!, where: SongWhereInput): BatchPayload!
  updateManyUsers(data: UserUpdateManyMutationInput!, where: UserWhereInput): BatchPayload!
  updateManyVotes(data: VoteUpdateManyMutationInput!, where: VoteWhereInput): BatchPayload!
  updateSong(data: SongUpdateInput!, where: SongWhereUniqueInput!): Song
  updateUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
  updateVote(data: VoteUpdateInput!, where: VoteWhereUniqueInput!): Vote
  upsertBracket(create: BracketCreateInput!, update: BracketUpdateInput!, where: BracketWhereUniqueInput!): Bracket!
  upsertSong(create: SongCreateInput!, update: SongUpdateInput!, where: SongWhereUniqueInput!): Song!
  upsertUser(create: UserCreateInput!, update: UserUpdateInput!, where: UserWhereUniqueInput!): User!
  upsertVote(create: VoteCreateInput!, update: VoteUpdateInput!, where: VoteWhereUniqueInput!): Vote!
}

type Query {
  brackets(after: String, before: String, first: Int, last: Int, orderBy: BracketOrderByInput, skip: Int, where: BracketWhereInput): [Bracket!]!
  users(after: String, before: String, first: Int, last: Int, orderBy: UserOrderByInput, skip: Int, where: UserWhereInput): [User!]!
}

type Song {
  album: String!
  id: ID!
  position: Int!
  spotifyID: String!
  title: String!
  votes(after: String, before: String, first: Int, last: Int, orderBy: VoteOrderByInput, skip: Int, where: VoteWhereInput): [Vote!]
  votingStatus: VotingStatus!
}

input SongCreateInput {
  album: String!
  id: ID
  position: Int!
  spotifyID: String!
  title: String!
  votes: VoteCreateManyWithoutSongInput
  votingStatus: VotingStatus!
}

input SongCreateManyInput {
  connect: [SongWhereUniqueInput!]
  create: [SongCreateInput!]
}

input SongCreateOneWithoutVotesInput {
  connect: SongWhereUniqueInput
  create: SongCreateWithoutVotesInput
}

input SongCreateWithoutVotesInput {
  album: String!
  id: ID
  position: Int!
  spotifyID: String!
  title: String!
  votingStatus: VotingStatus!
}

enum SongOrderByInput {
  album_ASC
  album_DESC
  createdAt_ASC
  createdAt_DESC
  id_ASC
  id_DESC
  position_ASC
  position_DESC
  spotifyID_ASC
  spotifyID_DESC
  title_ASC
  title_DESC
  updatedAt_ASC
  updatedAt_DESC
  votingStatus_ASC
  votingStatus_DESC
}

input SongScalarWhereInput {
  album: String
  album_contains: String
  album_ends_with: String
  album_gt: String
  album_gte: String
  album_in: [String!]
  album_lt: String
  album_lte: String
  album_not: String
  album_not_contains: String
  album_not_ends_with: String
  album_not_in: [String!]
  album_not_starts_with: String
  album_starts_with: String
  AND: [SongScalarWhereInput!]
  id: ID
  id_contains: ID
  id_ends_with: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_contains: ID
  id_not_ends_with: ID
  id_not_in: [ID!]
  id_not_starts_with: ID
  id_starts_with: ID
  NOT: [SongScalarWhereInput!]
  OR: [SongScalarWhereInput!]
  position: Int
  position_gt: Int
  position_gte: Int
  position_in: [Int!]
  position_lt: Int
  position_lte: Int
  position_not: Int
  position_not_in: [Int!]
  spotifyID: String
  spotifyID_contains: String
  spotifyID_ends_with: String
  spotifyID_gt: String
  spotifyID_gte: String
  spotifyID_in: [String!]
  spotifyID_lt: String
  spotifyID_lte: String
  spotifyID_not: String
  spotifyID_not_contains: String
  spotifyID_not_ends_with: String
  spotifyID_not_in: [String!]
  spotifyID_not_starts_with: String
  spotifyID_starts_with: String
  title: String
  title_contains: String
  title_ends_with: String
  title_gt: String
  title_gte: String
  title_in: [String!]
  title_lt: String
  title_lte: String
  title_not: String
  title_not_contains: String
  title_not_ends_with: String
  title_not_in: [String!]
  title_not_starts_with: String
  title_starts_with: String
  votingStatus: VotingStatus
  votingStatus_in: [VotingStatus!]
  votingStatus_not: VotingStatus
  votingStatus_not_in: [VotingStatus!]
}

input SongUpdateDataInput {
  album: String
  position: Int
  spotifyID: String
  title: String
  votes: VoteUpdateManyWithoutSongInput
  votingStatus: VotingStatus
}

input SongUpdateInput {
  album: String
  position: Int
  spotifyID: String
  title: String
  votes: VoteUpdateManyWithoutSongInput
  votingStatus: VotingStatus
}

input SongUpdateManyDataInput {
  album: String
  position: Int
  spotifyID: String
  title: String
  votingStatus: VotingStatus
}

input SongUpdateManyInput {
  connect: [SongWhereUniqueInput!]
  create: [SongCreateInput!]
  delete: [SongWhereUniqueInput!]
  deleteMany: [SongScalarWhereInput!]
  disconnect: [SongWhereUniqueInput!]
  set: [SongWhereUniqueInput!]
  update: [SongUpdateWithWhereUniqueNestedInput!]
  updateMany: [SongUpdateManyWithWhereNestedInput!]
  upsert: [SongUpsertWithWhereUniqueNestedInput!]
}

input SongUpdateManyMutationInput {
  album: String
  position: Int
  spotifyID: String
  title: String
  votingStatus: VotingStatus
}

input SongUpdateManyWithWhereNestedInput {
  data: SongUpdateManyDataInput!
  where: SongScalarWhereInput!
}

input SongUpdateOneWithoutVotesInput {
  connect: SongWhereUniqueInput
  create: SongCreateWithoutVotesInput
  delete: Boolean
  disconnect: Boolean
  update: SongUpdateWithoutVotesDataInput
  upsert: SongUpsertWithoutVotesInput
}

input SongUpdateWithoutVotesDataInput {
  album: String
  position: Int
  spotifyID: String
  title: String
  votingStatus: VotingStatus
}

input SongUpdateWithWhereUniqueNestedInput {
  data: SongUpdateDataInput!
  where: SongWhereUniqueInput!
}

input SongUpsertWithoutVotesInput {
  create: SongCreateWithoutVotesInput!
  update: SongUpdateWithoutVotesDataInput!
}

input SongUpsertWithWhereUniqueNestedInput {
  create: SongCreateInput!
  update: SongUpdateDataInput!
  where: SongWhereUniqueInput!
}

input SongWhereInput {
  album: String
  album_contains: String
  album_ends_with: String
  album_gt: String
  album_gte: String
  album_in: [String!]
  album_lt: String
  album_lte: String
  album_not: String
  album_not_contains: String
  album_not_ends_with: String
  album_not_in: [String!]
  album_not_starts_with: String
  album_starts_with: String
  AND: [SongWhereInput!]
  id: ID
  id_contains: ID
  id_ends_with: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_contains: ID
  id_not_ends_with: ID
  id_not_in: [ID!]
  id_not_starts_with: ID
  id_starts_with: ID
  NOT: [SongWhereInput!]
  OR: [SongWhereInput!]
  position: Int
  position_gt: Int
  position_gte: Int
  position_in: [Int!]
  position_lt: Int
  position_lte: Int
  position_not: Int
  position_not_in: [Int!]
  spotifyID: String
  spotifyID_contains: String
  spotifyID_ends_with: String
  spotifyID_gt: String
  spotifyID_gte: String
  spotifyID_in: [String!]
  spotifyID_lt: String
  spotifyID_lte: String
  spotifyID_not: String
  spotifyID_not_contains: String
  spotifyID_not_ends_with: String
  spotifyID_not_in: [String!]
  spotifyID_not_starts_with: String
  spotifyID_starts_with: String
  title: String
  title_contains: String
  title_ends_with: String
  title_gt: String
  title_gte: String
  title_in: [String!]
  title_lt: String
  title_lte: String
  title_not: String
  title_not_contains: String
  title_not_ends_with: String
  title_not_in: [String!]
  title_not_starts_with: String
  title_starts_with: String
  votes_every: VoteWhereInput
  votes_none: VoteWhereInput
  votes_some: VoteWhereInput
  votingStatus: VotingStatus
  votingStatus_in: [VotingStatus!]
  votingStatus_not: VotingStatus
  votingStatus_not_in: [VotingStatus!]
}

input SongWhereUniqueInput {
  id: ID
}

type User {
  brackets(after: String, before: String, first: Int, last: Int, orderBy: BracketOrderByInput, skip: Int, where: BracketWhereInput): [Bracket!]
  email: String!
  id: ID!
  password: String!
  username: String!
  votes(after: String, before: String, first: Int, last: Int, orderBy: VoteOrderByInput, skip: Int, where: VoteWhereInput): [Vote!]
}

input UserCreateInput {
  brackets: BracketCreateManyWithoutUserInput
  email: String!
  id: ID
  password: String!
  username: String!
  votes: VoteCreateManyWithoutUserInput
}

input UserCreateOneWithoutBracketsInput {
  connect: UserWhereUniqueInput
  create: UserCreateWithoutBracketsInput
}

input UserCreateOneWithoutVotesInput {
  connect: UserWhereUniqueInput
  create: UserCreateWithoutVotesInput
}

input UserCreateWithoutBracketsInput {
  email: String!
  id: ID
  password: String!
  username: String!
  votes: VoteCreateManyWithoutUserInput
}

input UserCreateWithoutVotesInput {
  brackets: BracketCreateManyWithoutUserInput
  email: String!
  id: ID
  password: String!
  username: String!
}

enum UserOrderByInput {
  createdAt_ASC
  createdAt_DESC
  email_ASC
  email_DESC
  id_ASC
  id_DESC
  password_ASC
  password_DESC
  updatedAt_ASC
  updatedAt_DESC
  username_ASC
  username_DESC
}

input UserUpdateInput {
  brackets: BracketUpdateManyWithoutUserInput
  email: String
  password: String
  username: String
  votes: VoteUpdateManyWithoutUserInput
}

input UserUpdateManyMutationInput {
  email: String
  password: String
  username: String
}

input UserUpdateOneRequiredWithoutBracketsInput {
  connect: UserWhereUniqueInput
  create: UserCreateWithoutBracketsInput
  update: UserUpdateWithoutBracketsDataInput
  upsert: UserUpsertWithoutBracketsInput
}

input UserUpdateOneRequiredWithoutVotesInput {
  connect: UserWhereUniqueInput
  create: UserCreateWithoutVotesInput
  update: UserUpdateWithoutVotesDataInput
  upsert: UserUpsertWithoutVotesInput
}

input UserUpdateWithoutBracketsDataInput {
  email: String
  password: String
  username: String
  votes: VoteUpdateManyWithoutUserInput
}

input UserUpdateWithoutVotesDataInput {
  brackets: BracketUpdateManyWithoutUserInput
  email: String
  password: String
  username: String
}

input UserUpsertWithoutBracketsInput {
  create: UserCreateWithoutBracketsInput!
  update: UserUpdateWithoutBracketsDataInput!
}

input UserUpsertWithoutVotesInput {
  create: UserCreateWithoutVotesInput!
  update: UserUpdateWithoutVotesDataInput!
}

input UserWhereInput {
  AND: [UserWhereInput!]
  brackets_every: BracketWhereInput
  brackets_none: BracketWhereInput
  brackets_some: BracketWhereInput
  email: String
  email_contains: String
  email_ends_with: String
  email_gt: String
  email_gte: String
  email_in: [String!]
  email_lt: String
  email_lte: String
  email_not: String
  email_not_contains: String
  email_not_ends_with: String
  email_not_in: [String!]
  email_not_starts_with: String
  email_starts_with: String
  id: ID
  id_contains: ID
  id_ends_with: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_contains: ID
  id_not_ends_with: ID
  id_not_in: [ID!]
  id_not_starts_with: ID
  id_starts_with: ID
  NOT: [UserWhereInput!]
  OR: [UserWhereInput!]
  password: String
  password_contains: String
  password_ends_with: String
  password_gt: String
  password_gte: String
  password_in: [String!]
  password_lt: String
  password_lte: String
  password_not: String
  password_not_contains: String
  password_not_ends_with: String
  password_not_in: [String!]
  password_not_starts_with: String
  password_starts_with: String
  username: String
  username_contains: String
  username_ends_with: String
  username_gt: String
  username_gte: String
  username_in: [String!]
  username_lt: String
  username_lte: String
  username_not: String
  username_not_contains: String
  username_not_ends_with: String
  username_not_in: [String!]
  username_not_starts_with: String
  username_starts_with: String
  votes_every: VoteWhereInput
  votes_none: VoteWhereInput
  votes_some: VoteWhereInput
}

input UserWhereUniqueInput {
  email: String
  id: ID
  username: String
}

type Vote {
  bracket: Bracket
  id: ID!
  song: Song
  user: User!
  voteType: Boolean
}

input VoteCreateInput {
  bracket: BracketCreateOneInput
  id: ID
  song: SongCreateOneWithoutVotesInput
  user: UserCreateOneWithoutVotesInput!
  voteType: Boolean
}

input VoteCreateManyWithoutSongInput {
  connect: [VoteWhereUniqueInput!]
  create: [VoteCreateWithoutSongInput!]
}

input VoteCreateManyWithoutUserInput {
  connect: [VoteWhereUniqueInput!]
  create: [VoteCreateWithoutUserInput!]
}

input VoteCreateWithoutSongInput {
  bracket: BracketCreateOneInput
  id: ID
  user: UserCreateOneWithoutVotesInput!
  voteType: Boolean
}

input VoteCreateWithoutUserInput {
  bracket: BracketCreateOneInput
  id: ID
  song: SongCreateOneWithoutVotesInput
  voteType: Boolean
}

enum VoteOrderByInput {
  createdAt_ASC
  createdAt_DESC
  id_ASC
  id_DESC
  updatedAt_ASC
  updatedAt_DESC
  voteType_ASC
  voteType_DESC
}

input VoteScalarWhereInput {
  AND: [VoteScalarWhereInput!]
  id: ID
  id_contains: ID
  id_ends_with: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_contains: ID
  id_not_ends_with: ID
  id_not_in: [ID!]
  id_not_starts_with: ID
  id_starts_with: ID
  NOT: [VoteScalarWhereInput!]
  OR: [VoteScalarWhereInput!]
  voteType: Boolean
  voteType_not: Boolean
}

input VoteUpdateInput {
  bracket: BracketUpdateOneInput
  song: SongUpdateOneWithoutVotesInput
  user: UserUpdateOneRequiredWithoutVotesInput
  voteType: Boolean
}

input VoteUpdateManyDataInput {
  voteType: Boolean
}

input VoteUpdateManyMutationInput {
  voteType: Boolean
}

input VoteUpdateManyWithoutSongInput {
  connect: [VoteWhereUniqueInput!]
  create: [VoteCreateWithoutSongInput!]
  delete: [VoteWhereUniqueInput!]
  deleteMany: [VoteScalarWhereInput!]
  disconnect: [VoteWhereUniqueInput!]
  set: [VoteWhereUniqueInput!]
  update: [VoteUpdateWithWhereUniqueWithoutSongInput!]
  updateMany: [VoteUpdateManyWithWhereNestedInput!]
  upsert: [VoteUpsertWithWhereUniqueWithoutSongInput!]
}

input VoteUpdateManyWithoutUserInput {
  connect: [VoteWhereUniqueInput!]
  create: [VoteCreateWithoutUserInput!]
  delete: [VoteWhereUniqueInput!]
  deleteMany: [VoteScalarWhereInput!]
  disconnect: [VoteWhereUniqueInput!]
  set: [VoteWhereUniqueInput!]
  update: [VoteUpdateWithWhereUniqueWithoutUserInput!]
  updateMany: [VoteUpdateManyWithWhereNestedInput!]
  upsert: [VoteUpsertWithWhereUniqueWithoutUserInput!]
}

input VoteUpdateManyWithWhereNestedInput {
  data: VoteUpdateManyDataInput!
  where: VoteScalarWhereInput!
}

input VoteUpdateWithoutSongDataInput {
  bracket: BracketUpdateOneInput
  user: UserUpdateOneRequiredWithoutVotesInput
  voteType: Boolean
}

input VoteUpdateWithoutUserDataInput {
  bracket: BracketUpdateOneInput
  song: SongUpdateOneWithoutVotesInput
  voteType: Boolean
}

input VoteUpdateWithWhereUniqueWithoutSongInput {
  data: VoteUpdateWithoutSongDataInput!
  where: VoteWhereUniqueInput!
}

input VoteUpdateWithWhereUniqueWithoutUserInput {
  data: VoteUpdateWithoutUserDataInput!
  where: VoteWhereUniqueInput!
}

input VoteUpsertWithWhereUniqueWithoutSongInput {
  create: VoteCreateWithoutSongInput!
  update: VoteUpdateWithoutSongDataInput!
  where: VoteWhereUniqueInput!
}

input VoteUpsertWithWhereUniqueWithoutUserInput {
  create: VoteCreateWithoutUserInput!
  update: VoteUpdateWithoutUserDataInput!
  where: VoteWhereUniqueInput!
}

input VoteWhereInput {
  AND: [VoteWhereInput!]
  bracket: BracketWhereInput
  id: ID
  id_contains: ID
  id_ends_with: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_contains: ID
  id_not_ends_with: ID
  id_not_in: [ID!]
  id_not_starts_with: ID
  id_starts_with: ID
  NOT: [VoteWhereInput!]
  OR: [VoteWhereInput!]
  song: SongWhereInput
  user: UserWhereInput
  voteType: Boolean
  voteType_not: Boolean
}

input VoteWhereUniqueInput {
  id: ID
}

enum VotingStatus {
  IN_PROGRESS
  LOSS
  WIN
}
